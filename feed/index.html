<?xml version='1.0' encoding='UTF-8'?>
<rss xmlns:atom="http://www.w3.org/2005/Atom" xmlns:content="http://purl.org/rss/1.0/modules/content/" version="2.0"><channel><title>心湖维基</title><link>/</link><description>愿此地一片净土,个人维基站</description><docs>http://www.rssboard.org/rss-specification</docs><generator>python-feedgen</generator><image><url>https://cdn.xn2001.com/img/head.jpg</url><title>心湖维基</title><link>/</link></image><language>zh-CN</language><lastBuildDate>Thu, 26 Mar 2020 10:13:20 +0806</lastBuildDate><pubDate>Thu, 26 Mar 2020 10:13:20 +0806</pubDate><item><title>教育邮箱免费申请正版idea(包括全家桶)</title><link>/archives/jetbrains-edu/</link><description>&lt;p&gt;进入申请界面：&lt;/p&gt;
&lt;p&gt;&lt;a href="https://www.jetbrains.com/shop/eform/students"&gt;https://www.jetbrains.com/shop/eform/students&lt;/a&gt;  填写相关信息。&lt;/p&gt;
&lt;p&gt;&lt;figure&gt;&lt;img data-width="767" data-height="1076" src="https://cdn.xn2001.com/2020/03/05/20200305002015-5.png" alt="" /&gt;&lt;/figure&gt;&lt;/p&gt;
&lt;p&gt;&lt;figure&gt;&lt;img data-width="752" data-height="412" src="https://cdn.xn2001.com/2020/03/05/20200305002015-4.png" alt="" /&gt;&lt;/figure&gt;&lt;/p&gt;
&lt;hr&gt;
&lt;p&gt;看到上面的界面时我们已经OK了，这时候去你的教育邮箱中查看是否有一份新邮件，可能需要1-2分钟时间&lt;/p&gt;
&lt;p&gt;&lt;figure&gt;&lt;img data-width="1440" data-height="502" src="https://cdn.xn2001.com/2020/03/05/20200305002015.png" alt="" /&gt;&lt;/figure&gt;&lt;/p&gt;
&lt;p&gt;这里需要你阅读2分钟左右的时长才会让你点击Accept&lt;/p&gt;
&lt;p&gt;&lt;figure&gt;&lt;img data-width="1918" data-height="898" src="https://cdn.xn2001.com/2020/03/05/20200305002311.png" alt="" /&gt;&lt;/figure&gt;&lt;/p&gt;
&lt;p&gt;输入你的教育邮箱开始进行注册，&lt;strong&gt;注意&lt;/strong&gt;是填写在下面的框。&lt;/p&gt;
&lt;p&gt;&lt;figure&gt;&lt;img data-width="1211" data-height="727" src="https://cdn.xn2001.com/2020/03/05/20200305002015-6.png" alt="" /&gt;&lt;/figure&gt;&lt;/p&gt;
&lt;p&gt;&lt;figure&gt;&lt;img data-width="951" data-height="876" src="https://cdn.xn2001.com/2020/03/05/20200305002015-2.png" alt="" /&gt;&lt;/figure&gt;&lt;/p&gt;
&lt;p&gt;&lt;figure&gt;&lt;img data-width="1154" data-height="850" src="https://cdn.xn2001.com/2020/03/05/20200305002015-1.png" alt="" /&gt;&lt;/figure&gt;&lt;/p&gt;
&lt;hr&gt;
&lt;p&gt;开始奔放吧，这里输入你注册的邮箱密码登录就可以啦。其他全家桶也是如此激活。（这里登录有时候会失败，登录几次就可以了。）&lt;/p&gt;
&lt;p&gt;&lt;figure&gt;&lt;img data-width="745" data-height="514" src="https://cdn.xn2001.com/2020/03/05/20200305002015-3.png" alt="" /&gt;&lt;/figure&gt;&lt;/p&gt;
</description><author>jialna@qq.com (乐心湖)</author><guid isPermaLink="true">/archives/jetbrains-edu/</guid><pubDate>Thu, 05 Mar 2020 01:09:00 +0806</pubDate></item><item><title>思-关于maven的dependencyManagement</title><link>/archives/dependencyManagement-maven/</link><description>&lt;h2&gt;Dependency Management&lt;/h2&gt;
&lt;p&gt;我们不妨先去看看官方的文档。&lt;/p&gt;
&lt;blockquote&gt;&lt;p&gt;Besides inheriting certain top-level elements, parents have elements to configure values for child &lt;code&gt;POMs&lt;/code&gt; and transitive dependencies. One of those elements is &lt;code&gt;dependencyManagement&lt;/code&gt;.&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;dependencyManagement&lt;/strong&gt;: is used by a POM to help manage dependency information across all of its children. If the &lt;code&gt;my-parent&lt;/code&gt; project uses &lt;code&gt;dependencyManagement&lt;/code&gt; to define a dependency on &lt;code&gt;junit:junit:4.12&lt;/code&gt;, then POMs inheriting from this one can set their dependency giving the &lt;code&gt;groupId&lt;/code&gt;=&lt;code&gt;junit&lt;/code&gt; and &lt;code&gt;artifactId&lt;/code&gt;=&lt;code&gt;junit&lt;/code&gt; only and Maven will fill in the &lt;code&gt;version&lt;/code&gt; set by the parent. The benefits of this method are obvious. Dependency details can be set in one central location, which propagates to all inheriting POMs.
Note that the version and scope of artifacts which are incorporated from transitive dependencies are also controlled by version specifications in a dependency management section. This can lead to unexpected consequences. Consider a case in which your project uses two dependences, &lt;code&gt;dep1&lt;/code&gt; and &lt;code&gt;dep2&lt;/code&gt;. &lt;code&gt;dep2&lt;/code&gt; in turn also uses &lt;code&gt;dep1&lt;/code&gt;, and requires a particular minimum version to function. If you then use &lt;code&gt;dependencyManagement&lt;/code&gt; to specify an older version, &lt;code&gt;dep2&lt;/code&gt; will be forced to use the older version, and fail. So, you must be careful to check the entire dependency tree to avoid this problem; &lt;code&gt;mvn dependency:tree&lt;/code&gt; is helpful.&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;我简单用大白话说一下他在讲什么，这个东西是用来管理依赖统一的，当你在父级依赖中拥有一个依赖，他就可以替你在子模块中搞定他的版本，只要你的子模块&lt;code&gt;groupId&lt;/code&gt;和&lt;code&gt;artifactId&lt;/code&gt;跟父级模块名字一样即可。很明显的好处就是版本规范统一控制。之后他说了可能发生的错误，叫你小心管理好依赖树，这方面我们也不用担心太多，因为我们有idea。大家看看官方原话，看英语文档确实很难，好在程序员写技术文档都会用通俗易懂的词汇（这里我说的也包括中文文档）。&lt;/p&gt;
&lt;p&gt;我们了解了这个东西之后，我寻思着为何没有例子，我把整个官方文档看了一遍也没找到，显然这不是Maven必需的，这样的版本规范控制，如果不是超大型项目又怎会用得到，大部分项目不过单模块业务处理，哪怕你是个多模块项目，也不外乎是三层提取，我们可以直接在父模块依赖中引入共有的，在子模块中引入自需的，我做项目便会如此。那么我为什么要写这个东西呢，因为我想将所有的学习源码都托管于Github，而不仅限于项目。这就导致我需要大量模块来进行分布，Maven就解决了我这一难题。&lt;/p&gt;
&lt;p&gt;回到上面，官方没有给例子，我们就自己来，毕竟编程容错率是非常高的。&lt;/p&gt;
&lt;p&gt;首先我们新建一个Maven的空项目，由于我们要用到多模块，我们将自带的src删除。&lt;/p&gt;
&lt;p&gt;&lt;figure&gt;&lt;img data-width="1475" data-height="745" src="https://cdn.xn2001.com/2020/03/06/20200306063055.png" alt="" /&gt;&lt;/figure&gt;&lt;/p&gt;
&lt;p&gt;我们来到项目下)的pom.xml，既然用到&lt;code&gt;dependencyManagement&lt;/code&gt;，我们就直接上代码。这里直接使用mysql和Lombok这两个依赖作为演示。（考虑到使用一个依赖可能不具备说服力，三个又搞得像在科研，因此二个为最佳）&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;&lt;span class="nt"&gt;&amp;lt;dependencyManagement&amp;gt;&lt;/span&gt;
        &lt;span class="nt"&gt;&amp;lt;dependencies&amp;gt;&lt;/span&gt;
            &lt;span class="nt"&gt;&amp;lt;dependency&amp;gt;&lt;/span&gt;
                &lt;span class="nt"&gt;&amp;lt;groupId&amp;gt;&lt;/span&gt;mysql&lt;span class="nt"&gt;&amp;lt;/groupId&amp;gt;&lt;/span&gt;
                &lt;span class="nt"&gt;&amp;lt;artifactId&amp;gt;&lt;/span&gt;mysql-connector-java&lt;span class="nt"&gt;&amp;lt;/artifactId&amp;gt;&lt;/span&gt;
                &lt;span class="nt"&gt;&amp;lt;version&amp;gt;&lt;/span&gt;8.0.18&lt;span class="nt"&gt;&amp;lt;/version&amp;gt;&lt;/span&gt;
            &lt;span class="nt"&gt;&amp;lt;/dependency&amp;gt;&lt;/span&gt;
            &lt;span class="nt"&gt;&amp;lt;dependency&amp;gt;&lt;/span&gt;
                &lt;span class="nt"&gt;&amp;lt;groupId&amp;gt;&lt;/span&gt;org.projectlombok&lt;span class="nt"&gt;&amp;lt;/groupId&amp;gt;&lt;/span&gt;
                &lt;span class="nt"&gt;&amp;lt;artifactId&amp;gt;&lt;/span&gt;lombok&lt;span class="nt"&gt;&amp;lt;/artifactId&amp;gt;&lt;/span&gt;
                &lt;span class="nt"&gt;&amp;lt;version&amp;gt;&lt;/span&gt;1.18.10&lt;span class="nt"&gt;&amp;lt;/version&amp;gt;&lt;/span&gt;
                &lt;span class="nt"&gt;&amp;lt;scope&amp;gt;&lt;/span&gt;provided&lt;span class="nt"&gt;&amp;lt;/scope&amp;gt;&lt;/span&gt;
            &lt;span class="nt"&gt;&amp;lt;/dependency&amp;gt;&lt;/span&gt;
        &lt;span class="nt"&gt;&amp;lt;/dependencies&amp;gt;&lt;/span&gt;
    &lt;span class="nt"&gt;&amp;lt;/dependencyManagement&amp;gt;&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;上面的写法使得版本号也在其中，依赖较多时不方便管理，我们养成习惯提取出来。&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;&lt;span class="nt"&gt;&amp;lt;properties&amp;gt;&lt;/span&gt;
        &lt;span class="nt"&gt;&amp;lt;mysql.connector.version&amp;gt;&lt;/span&gt;8.0.18&lt;span class="nt"&gt;&amp;lt;/mysql.connector.version&amp;gt;&lt;/span&gt;
        &lt;span class="nt"&gt;&amp;lt;lombok.version&amp;gt;&lt;/span&gt;1.18.10&lt;span class="nt"&gt;&amp;lt;/lombok.version&amp;gt;&lt;/span&gt;
    &lt;span class="nt"&gt;&amp;lt;/properties&amp;gt;&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;将原本的&lt;/p&gt;
&lt;p&gt;&lt;code&gt;&amp;lt;version&amp;gt;8.0.18&amp;lt;/version&amp;gt;&lt;/code&gt;修改为&lt;code&gt;&amp;lt;version&amp;gt;${mysql.connector.version}&amp;lt;/version&amp;gt;&lt;/code&gt;&lt;/p&gt;
&lt;p&gt;&lt;code&gt;&amp;lt;version&amp;gt;1.18.10&amp;lt;/version&amp;gt;&lt;/code&gt;修改为 &lt;code&gt;&amp;lt;version&amp;gt;${lombok.version}&amp;lt;/version&amp;gt;&lt;/code&gt;&lt;/p&gt;
&lt;p&gt;我们更新一下Maven，会发现项目中并没有引入依赖，这就很好的说明了&lt;code&gt;dependencyManagement&lt;/code&gt;和&lt;code&gt;dependencies&lt;/code&gt;的区别，也展示出它的优越之处，子模块只需要放心使用依赖而无需考虑版本冲突问题。同时很好的解决了新手打包项目时优化不佳导致体积过大。&lt;/p&gt;
&lt;p&gt;&lt;figure&gt;&lt;img data-width="1026" data-height="401" src="https://cdn.xn2001.com/2020/03/06/20200306065552.png" alt="" /&gt;&lt;/figure&gt;&lt;/p&gt;
&lt;p&gt;接下来我们去新建一个Module(模块)，进入模块下的pom.xml&lt;/p&gt;
&lt;p&gt;&lt;figure&gt;&lt;img data-width="898" data-height="312" src="https://cdn.xn2001.com/2020/03/06/20200306071252.png" alt="" /&gt;&lt;/figure&gt;&lt;/p&gt;
&lt;p&gt;我们加入在父模块中的两个依赖，看看是否能在子模块中引入。按照官方文档，你只要&lt;code&gt;groupId&lt;/code&gt;和&lt;code&gt;artifactId&lt;/code&gt;跟父模块一一对应，也就是名字相同即可。&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;&lt;span class="nt"&gt;&amp;lt;dependencies&amp;gt;&lt;/span&gt;
        &lt;span class="nt"&gt;&amp;lt;dependency&amp;gt;&lt;/span&gt;
            &lt;span class="nt"&gt;&amp;lt;groupId&amp;gt;&lt;/span&gt;mysql&lt;span class="nt"&gt;&amp;lt;/groupId&amp;gt;&lt;/span&gt;
            &lt;span class="nt"&gt;&amp;lt;artifactId&amp;gt;&lt;/span&gt;mysql-connector-java&lt;span class="nt"&gt;&amp;lt;/artifactId&amp;gt;&lt;/span&gt;
        &lt;span class="nt"&gt;&amp;lt;/dependency&amp;gt;&lt;/span&gt;
        &lt;span class="nt"&gt;&amp;lt;dependency&amp;gt;&lt;/span&gt;
            &lt;span class="nt"&gt;&amp;lt;groupId&amp;gt;&lt;/span&gt;org.projectlombok&lt;span class="nt"&gt;&amp;lt;/groupId&amp;gt;&lt;/span&gt;
            &lt;span class="nt"&gt;&amp;lt;artifactId&amp;gt;&lt;/span&gt;lombok&lt;span class="nt"&gt;&amp;lt;/artifactId&amp;gt;&lt;/span&gt;
        &lt;span class="nt"&gt;&amp;lt;/dependency&amp;gt;&lt;/span&gt;
    &lt;span class="nt"&gt;&amp;lt;/dependencies&amp;gt;&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;&lt;figure&gt;&lt;img data-width="704" data-height="389" src="https://cdn.xn2001.com/2020/03/06/20200306072453.png" alt="" /&gt;&lt;/figure&gt;&lt;/p&gt;
&lt;p&gt;结果跟预期的一样，我们再去新建一个模块，试着只引入mysql。&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;&lt;span class="nt"&gt;&amp;lt;dependencies&amp;gt;&lt;/span&gt;
        &lt;span class="nt"&gt;&amp;lt;dependency&amp;gt;&lt;/span&gt;
            &lt;span class="nt"&gt;&amp;lt;groupId&amp;gt;&lt;/span&gt;mysql&lt;span class="nt"&gt;&amp;lt;/groupId&amp;gt;&lt;/span&gt;
            &lt;span class="nt"&gt;&amp;lt;artifactId&amp;gt;&lt;/span&gt;mysql-connector-java&lt;span class="nt"&gt;&amp;lt;/artifactId&amp;gt;&lt;/span&gt;
        &lt;span class="nt"&gt;&amp;lt;/dependency&amp;gt;&lt;/span&gt;
    &lt;span class="nt"&gt;&amp;lt;/dependencies&amp;gt;&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;&lt;figure&gt;&lt;img data-width="547" data-height="507" src="https://cdn.xn2001.com/2020/03/06/20200306072750.png" alt="" /&gt;&lt;/figure&gt;&lt;/p&gt;
&lt;p&gt;到这里我们的测试就已经完成了，我们不难发现版本管理这思想与SpringBoot有异曲同工之妙，但却比SpringBoot要灵活得多。&lt;/p&gt;
&lt;blockquote&gt;&lt;p&gt;想来自己也是很用心写下这篇博客，与其说它是教程，不如说是对一个东西的思考与实践。所以我认为这篇博客不存在长篇大论，这也是我更愿意看到的技术博客。它面对的是新学习的人，如果你已经了解过这个东西，单单是因为忘记了一个知识点想通过百度来获取使用方法，那我更提倡你学习时为自己记录笔记，一方面提升你的知识索引速度，也增强你的知识掌握。所以我会将这篇博客再分离出一篇较简短的使用方法，来方便自己日后查阅。&lt;/p&gt;
&lt;/blockquote&gt;
</description><author>jialna@qq.com (乐心湖)</author><guid isPermaLink="true">/archives/dependencyManagement-maven/</guid><pubDate>Fri, 06 Mar 2020 12:10:00 +0806</pubDate></item><item><title>如何制作圆形头像或图片</title><link>/archives/head-circular/</link><description>&lt;blockquote&gt;&lt;p&gt;有时候我们为了效果展示，需要把头像或者图片转化为圆形。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;&lt;strong&gt;原理：我们利用Photoshop的椭圆选区工具，将未选择的区域删除，就得到了我们想要的效果啦。&lt;/strong&gt;&lt;/p&gt;
&lt;h3&gt;实现：&lt;/h3&gt;
&lt;h4&gt;1. 打开Photoshop&lt;/h4&gt;
&lt;p&gt;打开你需要操作的图片，如果太小就按下Ctrl+0，再按下shift+Ctrl+n，新建一个图层（Ctrl+j），将底图取消显示。&lt;/p&gt;
&lt;p&gt;&lt;figure&gt;&lt;img data-width="1352" data-height="911" src="https://cdn.xn2001.com/2020/03/08/20200308173217.png" alt="" /&gt;&lt;/figure&gt;&lt;/p&gt;
&lt;p&gt;&lt;img src="https://cdn.xn2001.com/2020/03/08/20200308174140.png" style="zoom: 67%;" /&gt;&lt;/p&gt;
&lt;h4&gt;2. 选择椭圆工具&lt;/h4&gt;
&lt;p&gt;&lt;figure&gt;&lt;img data-width="1402" data-height="951" src="https://cdn.xn2001.com/2020/03/08/20200308173353.png" alt="" /&gt;&lt;/figure&gt;&lt;/p&gt;
&lt;h4&gt;3. 选择区域&lt;/h4&gt;
&lt;p&gt;按住shift不放，拖动鼠标，勾画出圆形区域，确定选区（Ctrl+回车），切换到原图，反选区域（shift+Ctrl+j），按下del删除键。&lt;/p&gt;
&lt;p&gt;&lt;figure&gt;&lt;img data-width="1311" data-height="870" src="https://cdn.xn2001.com/2020/03/08/20200308174414.png" alt="" /&gt;&lt;/figure&gt;&lt;/p&gt;
&lt;p&gt;&lt;figure&gt;&lt;img data-width="1846" data-height="950" src="https://cdn.xn2001.com/2020/03/08/20200308174507.png" alt="" /&gt;&lt;/figure&gt;&lt;/p&gt;
&lt;p&gt;&lt;figure&gt;&lt;img data-width="1311" data-height="870" src="https://cdn.xn2001.com/2020/03/08/20200308174549.png" alt="" /&gt;&lt;/figure&gt;&lt;/p&gt;
&lt;p&gt;如果需要裁剪的话，这里有个裁剪工具。&lt;/p&gt;
&lt;p&gt;&lt;figure&gt;&lt;img data-width="550" data-height="487" src="https://cdn.xn2001.com/2020/03/08/20200308174630.png" alt="" /&gt;&lt;/figure&gt;&lt;/p&gt;
&lt;h4&gt;4. 导出图像&lt;/h4&gt;
&lt;p&gt;&lt;figure&gt;&lt;img data-width="1014" data-height="861" src="https://cdn.xn2001.com/2020/03/08/20200308174818.png" alt="" /&gt;&lt;/figure&gt;&lt;/p&gt;
&lt;p&gt;&lt;figure&gt;&lt;img data-width="1375" data-height="875" src="https://cdn.xn2001.com/2020/03/08/20200308174909.png" alt="" /&gt;&lt;/figure&gt;&lt;/p&gt;
&lt;p&gt;选择PNG可以导出背景是透明的圆形头像，大功告成。&lt;/p&gt;
</description><author>jialna@qq.com (乐心湖)</author><guid isPermaLink="true">/archives/head-circular/</guid><pubDate>Sun, 08 Mar 2020 12:10:00 +0806</pubDate></item><item><title>Java多线程的实现方式</title><link>/archives/thread-know-java/</link><description>&lt;h2&gt;并发和并行&lt;/h2&gt;
&lt;p&gt;并发:在同一时刻,有多个指令在&lt;strong&gt;单个CPU&lt;/strong&gt;上&lt;strong&gt;交替&lt;/strong&gt;执行.&lt;/p&gt;
&lt;p&gt;并行:在同一时刻,有多个指令在&lt;strong&gt;多个CPU&lt;/strong&gt;上&lt;strong&gt;同时&lt;/strong&gt;执行.&lt;/p&gt;
&lt;h2&gt;进程和线程&lt;/h2&gt;
&lt;p&gt;进程:正在运行的软件.&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;独立性:进程是一个能独立运行的基本单位,同时也是系统分配资源和调度的独立单位.&lt;/li&gt;
&lt;li&gt;动态性:进程的实质是程序的一次执行过程,进程是动态产生,动态消亡的.&lt;/li&gt;
&lt;li&gt;并发性:任何进程都可以同其他进程一起并发执行.&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;线程:进程中的单个顺序控制流,是一条执行路径.&lt;/p&gt;
&lt;h2&gt;多线程的实现方式&lt;/h2&gt;
&lt;ul&gt;
&lt;li&gt;继承Thread类的方式进行实现&lt;/li&gt;
&lt;li&gt;实现Runnable接口的方式进行实现&lt;/li&gt;
&lt;li&gt;利用Callable和Future接口方式实现&lt;/li&gt;
&lt;/ul&gt;
&lt;h2&gt;多线程的实现方案&lt;/h2&gt;
&lt;h3&gt;方式1：继承Thread类&lt;/h3&gt;
&lt;ol&gt;
&lt;li&gt;定义一个类如MyThread继承Thread类&lt;/li&gt;
&lt;li&gt;在MyThread类中重写run()方法&lt;/li&gt;
&lt;li&gt;创建MyThread类的对象&lt;/li&gt;
&lt;li&gt;启动线程&lt;/li&gt;
&lt;/ol&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;&lt;span class="kd"&gt;public&lt;/span&gt; &lt;span class="kd"&gt;class&lt;/span&gt; &lt;span class="nc"&gt;MyThread&lt;/span&gt; &lt;span class="kd"&gt;extends&lt;/span&gt; &lt;span class="n"&gt;Thread&lt;/span&gt; &lt;span class="p"&gt;{&lt;/span&gt;
    &lt;span class="nd"&gt;@Override&lt;/span&gt;
    &lt;span class="kd"&gt;public&lt;/span&gt; &lt;span class="kt"&gt;void&lt;/span&gt; &lt;span class="nf"&gt;run&lt;/span&gt;&lt;span class="p"&gt;()&lt;/span&gt; &lt;span class="p"&gt;{&lt;/span&gt;
&lt;span class="c1"&gt;//        run方法是执行的内容&lt;/span&gt;
        &lt;span class="k"&gt;for&lt;/span&gt; &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="kt"&gt;int&lt;/span&gt; &lt;span class="n"&gt;i&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="mi"&gt;0&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt; &lt;span class="n"&gt;i&lt;/span&gt; &lt;span class="o"&gt;&amp;lt;&lt;/span&gt; &lt;span class="mi"&gt;100&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt; &lt;span class="n"&gt;i&lt;/span&gt;&lt;span class="o"&gt;++&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt; &lt;span class="p"&gt;{&lt;/span&gt;
            &lt;span class="n"&gt;System&lt;/span&gt;&lt;span class="p"&gt;.&lt;/span&gt;&lt;span class="na"&gt;out&lt;/span&gt;&lt;span class="p"&gt;.&lt;/span&gt;&lt;span class="na"&gt;println&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="s"&gt;&amp;quot;线程开启了&amp;quot;&lt;/span&gt;&lt;span class="o"&gt;+&lt;/span&gt;&lt;span class="n"&gt;i&lt;/span&gt;&lt;span class="p"&gt;);&lt;/span&gt;
        &lt;span class="p"&gt;}&lt;/span&gt;
    &lt;span class="p"&gt;}&lt;/span&gt;
&lt;span class="p"&gt;}&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;&lt;span class="kd"&gt;public&lt;/span&gt; &lt;span class="kd"&gt;class&lt;/span&gt; &lt;span class="nc"&gt;MyThreadTest&lt;/span&gt; &lt;span class="p"&gt;{&lt;/span&gt;
    &lt;span class="kd"&gt;public&lt;/span&gt; &lt;span class="kd"&gt;static&lt;/span&gt; &lt;span class="kt"&gt;void&lt;/span&gt; &lt;span class="nf"&gt;main&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;String&lt;/span&gt;&lt;span class="o"&gt;[]&lt;/span&gt; &lt;span class="n"&gt;args&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt; &lt;span class="p"&gt;{&lt;/span&gt;
        &lt;span class="n"&gt;MyThread&lt;/span&gt; &lt;span class="n"&gt;t1&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="k"&gt;new&lt;/span&gt; &lt;span class="n"&gt;MyThread&lt;/span&gt;&lt;span class="p"&gt;();&lt;/span&gt;
        &lt;span class="n"&gt;MyThread&lt;/span&gt; &lt;span class="n"&gt;t2&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="k"&gt;new&lt;/span&gt; &lt;span class="n"&gt;MyThread&lt;/span&gt;&lt;span class="p"&gt;();&lt;/span&gt;
        &lt;span class="n"&gt;t1&lt;/span&gt;&lt;span class="p"&gt;.&lt;/span&gt;&lt;span class="na"&gt;start&lt;/span&gt;&lt;span class="p"&gt;();&lt;/span&gt;
        &lt;span class="n"&gt;t2&lt;/span&gt;&lt;span class="p"&gt;.&lt;/span&gt;&lt;span class="na"&gt;start&lt;/span&gt;&lt;span class="p"&gt;();&lt;/span&gt;
&lt;span class="c1"&gt;//        可以发现两个线程是交替执行的&lt;/span&gt;
    &lt;span class="p"&gt;}&lt;/span&gt;
&lt;span class="p"&gt;}&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;h4&gt;两个小问题&lt;/h4&gt;
&lt;p&gt;为什么要重写run方法？&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;因为run是用来封装被线程执行的代码&lt;/li&gt;
&lt;li&gt;run()方法和start()方法的区别？&lt;/li&gt;
&lt;li&gt;run()：封装线程执行的代码，直接调用，相当于普通方法的调用，并没有开启线程.&lt;/li&gt;
&lt;li&gt;start()：启动线程；然后由VM调用此线程的run()方法.&lt;/li&gt;
&lt;/ul&gt;
&lt;h3&gt;方式2：实现Runnable&lt;/h3&gt;
&lt;ol&gt;
&lt;li&gt;&lt;p&gt;定义一个类MyRunnable实现Runnable接口&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;&lt;p&gt;在MyRunnable类中重写run()方法&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;&lt;p&gt;创建MyRunnable类的对象&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;&lt;p&gt;创建Thread类的对象，把MyRunnable对象作为构造方法的参数&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;&lt;p&gt;启动线程&lt;/p&gt;
&lt;/li&gt;
&lt;/ol&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;&lt;span class="kd"&gt;public&lt;/span&gt; &lt;span class="kd"&gt;class&lt;/span&gt; &lt;span class="nc"&gt;MyRunnable&lt;/span&gt; &lt;span class="kd"&gt;implements&lt;/span&gt; &lt;span class="n"&gt;Runnable&lt;/span&gt; &lt;span class="p"&gt;{&lt;/span&gt;
    &lt;span class="nd"&gt;@Override&lt;/span&gt;
    &lt;span class="kd"&gt;public&lt;/span&gt; &lt;span class="kt"&gt;void&lt;/span&gt; &lt;span class="nf"&gt;run&lt;/span&gt;&lt;span class="p"&gt;()&lt;/span&gt; &lt;span class="p"&gt;{&lt;/span&gt;
        &lt;span class="k"&gt;for&lt;/span&gt; &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="kt"&gt;int&lt;/span&gt; &lt;span class="n"&gt;i&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="mi"&gt;0&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt; &lt;span class="n"&gt;i&lt;/span&gt; &lt;span class="o"&gt;&amp;lt;&lt;/span&gt; &lt;span class="mi"&gt;100&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt; &lt;span class="n"&gt;i&lt;/span&gt;&lt;span class="o"&gt;++&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt; &lt;span class="p"&gt;{&lt;/span&gt;
            &lt;span class="n"&gt;System&lt;/span&gt;&lt;span class="p"&gt;.&lt;/span&gt;&lt;span class="na"&gt;out&lt;/span&gt;&lt;span class="p"&gt;.&lt;/span&gt;&lt;span class="na"&gt;println&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="s"&gt;&amp;quot;第二种方式&amp;quot;&lt;/span&gt;&lt;span class="o"&gt;+&lt;/span&gt;&lt;span class="n"&gt;i&lt;/span&gt;&lt;span class="p"&gt;);&lt;/span&gt;
        &lt;span class="p"&gt;}&lt;/span&gt;
    &lt;span class="p"&gt;}&lt;/span&gt;
&lt;span class="p"&gt;}&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;&lt;span class="kd"&gt;public&lt;/span&gt; &lt;span class="kd"&gt;class&lt;/span&gt; &lt;span class="nc"&gt;MyRunnableTest&lt;/span&gt; &lt;span class="p"&gt;{&lt;/span&gt;
    &lt;span class="kd"&gt;public&lt;/span&gt; &lt;span class="kd"&gt;static&lt;/span&gt; &lt;span class="kt"&gt;void&lt;/span&gt; &lt;span class="nf"&gt;main&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;String&lt;/span&gt;&lt;span class="o"&gt;[]&lt;/span&gt; &lt;span class="n"&gt;args&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt; &lt;span class="p"&gt;{&lt;/span&gt;
&lt;span class="c1"&gt;//        创建一个参数对象&lt;/span&gt;
        &lt;span class="n"&gt;MyRunnable&lt;/span&gt; &lt;span class="n"&gt;m1&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="k"&gt;new&lt;/span&gt; &lt;span class="n"&gt;MyRunnable&lt;/span&gt;&lt;span class="p"&gt;();&lt;/span&gt;
        &lt;span class="n"&gt;MyRunnable&lt;/span&gt; &lt;span class="n"&gt;m2&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="k"&gt;new&lt;/span&gt; &lt;span class="n"&gt;MyRunnable&lt;/span&gt;&lt;span class="p"&gt;();&lt;/span&gt;
&lt;span class="c1"&gt;//        创建一个线程对象,并把参数传给这个线程&lt;/span&gt;
        &lt;span class="n"&gt;Thread&lt;/span&gt; &lt;span class="n"&gt;t1&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="k"&gt;new&lt;/span&gt; &lt;span class="n"&gt;Thread&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;m1&lt;/span&gt;&lt;span class="p"&gt;);&lt;/span&gt;
        &lt;span class="n"&gt;Thread&lt;/span&gt; &lt;span class="n"&gt;t2&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="k"&gt;new&lt;/span&gt; &lt;span class="n"&gt;Thread&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;m2&lt;/span&gt;&lt;span class="p"&gt;);&lt;/span&gt;
&lt;span class="c1"&gt;//        开启线程&lt;/span&gt;
        &lt;span class="n"&gt;t1&lt;/span&gt;&lt;span class="p"&gt;.&lt;/span&gt;&lt;span class="na"&gt;start&lt;/span&gt;&lt;span class="p"&gt;();&lt;/span&gt;
        &lt;span class="n"&gt;t2&lt;/span&gt;&lt;span class="p"&gt;.&lt;/span&gt;&lt;span class="na"&gt;start&lt;/span&gt;&lt;span class="p"&gt;();&lt;/span&gt;
    &lt;span class="p"&gt;}&lt;/span&gt;
&lt;span class="p"&gt;}&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;h3&gt;方式3：Callable和Future&lt;/h3&gt;
&lt;ol&gt;
&lt;li&gt;定义一个类MyCallable实现Callable接口&lt;/li&gt;
&lt;li&gt;在MyCallable类中重写call()方法·创建MyCallable类的对象&lt;/li&gt;
&lt;li&gt;创建Future的实现类FutureTask对象，把MyCallable对象作为构造方法的参数&lt;/li&gt;
&lt;li&gt;创建Thread类的对象，把FutureTask对象作为构造方法的参数&lt;/li&gt;
&lt;li&gt;启动线程&lt;/li&gt;
&lt;li&gt;再调用get方法，就可以获取线看程结束之后的结果。&lt;/li&gt;
&lt;li&gt;值得注意的是:get方法要在start开启之后调用.&lt;/li&gt;
&lt;/ol&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;&lt;span class="kd"&gt;public&lt;/span&gt; &lt;span class="kd"&gt;class&lt;/span&gt; &lt;span class="nc"&gt;MyCallable&lt;/span&gt; &lt;span class="kd"&gt;implements&lt;/span&gt; &lt;span class="n"&gt;Callable&lt;/span&gt;&lt;span class="o"&gt;&amp;lt;&lt;/span&gt;&lt;span class="n"&gt;String&lt;/span&gt;&lt;span class="o"&gt;&amp;gt;&lt;/span&gt;&lt;span class="p"&gt;{&lt;/span&gt;
    &lt;span class="nd"&gt;@Override&lt;/span&gt;
    &lt;span class="kd"&gt;public&lt;/span&gt; &lt;span class="n"&gt;String&lt;/span&gt; &lt;span class="nf"&gt;call&lt;/span&gt;&lt;span class="p"&gt;()&lt;/span&gt; &lt;span class="kd"&gt;throws&lt;/span&gt; &lt;span class="n"&gt;Exception&lt;/span&gt; &lt;span class="p"&gt;{&lt;/span&gt;
        &lt;span class="k"&gt;for&lt;/span&gt; &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="kt"&gt;int&lt;/span&gt; &lt;span class="n"&gt;i&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="mi"&gt;0&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt; &lt;span class="n"&gt;i&lt;/span&gt; &lt;span class="o"&gt;&amp;lt;&lt;/span&gt; &lt;span class="mi"&gt;100&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt; &lt;span class="n"&gt;i&lt;/span&gt;&lt;span class="o"&gt;++&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt; &lt;span class="p"&gt;{&lt;/span&gt;
            &lt;span class="n"&gt;System&lt;/span&gt;&lt;span class="p"&gt;.&lt;/span&gt;&lt;span class="na"&gt;out&lt;/span&gt;&lt;span class="p"&gt;.&lt;/span&gt;&lt;span class="na"&gt;println&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="s"&gt;&amp;quot;线程执行中&amp;quot;&lt;/span&gt;&lt;span class="o"&gt;+&lt;/span&gt;&lt;span class="n"&gt;i&lt;/span&gt;&lt;span class="p"&gt;);&lt;/span&gt;
        &lt;span class="p"&gt;}&lt;/span&gt;
        &lt;span class="k"&gt;return&lt;/span&gt; &lt;span class="s"&gt;&amp;quot;线程执行完成&amp;quot;&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;
    &lt;span class="p"&gt;}&lt;/span&gt;
&lt;span class="p"&gt;}&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;&lt;span class="kd"&gt;public&lt;/span&gt; &lt;span class="kd"&gt;class&lt;/span&gt; &lt;span class="nc"&gt;MyCallableTest&lt;/span&gt; &lt;span class="p"&gt;{&lt;/span&gt;
    &lt;span class="kd"&gt;public&lt;/span&gt; &lt;span class="kd"&gt;static&lt;/span&gt; &lt;span class="kt"&gt;void&lt;/span&gt; &lt;span class="nf"&gt;main&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;String&lt;/span&gt;&lt;span class="o"&gt;[]&lt;/span&gt; &lt;span class="n"&gt;args&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt; &lt;span class="kd"&gt;throws&lt;/span&gt; &lt;span class="n"&gt;ExecutionException&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="n"&gt;InterruptedException&lt;/span&gt; &lt;span class="p"&gt;{&lt;/span&gt;
        &lt;span class="n"&gt;MyCallable&lt;/span&gt; &lt;span class="n"&gt;m1&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="k"&gt;new&lt;/span&gt; &lt;span class="n"&gt;MyCallable&lt;/span&gt;&lt;span class="p"&gt;();&lt;/span&gt;
&lt;span class="c1"&gt;//        可以获取线程执行后的结果,也可以作为参数传递诶Thread&lt;/span&gt;
        &lt;span class="n"&gt;FutureTask&lt;/span&gt;&lt;span class="o"&gt;&amp;lt;&lt;/span&gt;&lt;span class="n"&gt;String&lt;/span&gt;&lt;span class="o"&gt;&amp;gt;&lt;/span&gt; &lt;span class="n"&gt;f1&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="k"&gt;new&lt;/span&gt; &lt;span class="n"&gt;FutureTask&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;m1&lt;/span&gt;&lt;span class="p"&gt;);&lt;/span&gt;
        &lt;span class="n"&gt;Thread&lt;/span&gt; &lt;span class="n"&gt;t1&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="k"&gt;new&lt;/span&gt; &lt;span class="n"&gt;Thread&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;f1&lt;/span&gt;&lt;span class="p"&gt;);&lt;/span&gt;
&lt;span class="c1"&gt;//        开启线程&lt;/span&gt;
        &lt;span class="n"&gt;t1&lt;/span&gt;&lt;span class="p"&gt;.&lt;/span&gt;&lt;span class="na"&gt;start&lt;/span&gt;&lt;span class="p"&gt;();&lt;/span&gt;
&lt;span class="c1"&gt;//        返回值&lt;/span&gt;
        &lt;span class="n"&gt;String&lt;/span&gt; &lt;span class="n"&gt;o&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="n"&gt;f1&lt;/span&gt;&lt;span class="p"&gt;.&lt;/span&gt;&lt;span class="na"&gt;get&lt;/span&gt;&lt;span class="p"&gt;();&lt;/span&gt;
        &lt;span class="n"&gt;System&lt;/span&gt;&lt;span class="p"&gt;.&lt;/span&gt;&lt;span class="na"&gt;out&lt;/span&gt;&lt;span class="p"&gt;.&lt;/span&gt;&lt;span class="na"&gt;println&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;o&lt;/span&gt;&lt;span class="p"&gt;);&lt;/span&gt;
    &lt;span class="p"&gt;}&lt;/span&gt;
&lt;span class="p"&gt;}&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
</description><author>jialna@qq.com (乐心湖)</author><guid isPermaLink="true">/archives/thread-know-java/</guid><pubDate>Mon, 09 Mar 2020 12:10:00 +0806</pubDate></item><item><title>Java多线程的常见方法</title><link>/archives/thread-void-java/</link><description>&lt;h2&gt;三种多线程实现方式的优缺点&lt;/h2&gt;
&lt;table&gt;
&lt;thead&gt;&lt;tr&gt;
&lt;th&gt;&lt;/th&gt;
&lt;th&gt;优点&lt;/th&gt;
&lt;th&gt;缺点&lt;/th&gt;
&lt;/tr&gt;
&lt;/thead&gt;
&lt;tbody&gt;
&lt;tr&gt;
&lt;td&gt;实现Runnable、Callable接口&lt;/td&gt;
&lt;td&gt;扩展性强，实现该接口的同时还可以继承其他的类&lt;/td&gt;
&lt;td&gt;编程相对复杂,不能直接使用Thread类的方法&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;继承Thread类&lt;/td&gt;
&lt;td&gt;编程比较简单，可以直接使用Thread类中的方法&lt;/td&gt;
&lt;td&gt;扩展性较差，不能继承其他的类&lt;/td&gt;
&lt;/tr&gt;
&lt;/tbody&gt;
&lt;/table&gt;
&lt;h2&gt;获取和设置线程名称&lt;/h2&gt;
&lt;p&gt;获取线程的名称&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;String getName() ：返回此线程的名称&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;设置线程的名称&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;直接在创建对象时通过构造方法传参&lt;/li&gt;
&lt;li&gt;void setName(String name) &lt;/li&gt;
&lt;/ul&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;&lt;span class="kd"&gt;public&lt;/span&gt; &lt;span class="kd"&gt;class&lt;/span&gt; &lt;span class="nc"&gt;MyThread&lt;/span&gt; &lt;span class="kd"&gt;extends&lt;/span&gt; &lt;span class="n"&gt;Thread&lt;/span&gt; &lt;span class="p"&gt;{&lt;/span&gt;
    &lt;span class="kd"&gt;public&lt;/span&gt; &lt;span class="nf"&gt;MyThread&lt;/span&gt;&lt;span class="p"&gt;()&lt;/span&gt; &lt;span class="p"&gt;{}&lt;/span&gt;

    &lt;span class="kd"&gt;public&lt;/span&gt; &lt;span class="nf"&gt;MyThread&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;String&lt;/span&gt; &lt;span class="n"&gt;name&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt; &lt;span class="p"&gt;{&lt;/span&gt;
        &lt;span class="kd"&gt;super&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;name&lt;/span&gt;&lt;span class="p"&gt;);&lt;/span&gt;
    &lt;span class="p"&gt;}&lt;/span&gt;
    &lt;span class="nd"&gt;@Override&lt;/span&gt;
    &lt;span class="kd"&gt;public&lt;/span&gt; &lt;span class="kt"&gt;void&lt;/span&gt; &lt;span class="nf"&gt;run&lt;/span&gt;&lt;span class="p"&gt;()&lt;/span&gt; &lt;span class="p"&gt;{&lt;/span&gt;
        &lt;span class="k"&gt;for&lt;/span&gt; &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="kt"&gt;int&lt;/span&gt; &lt;span class="n"&gt;i&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="mi"&gt;0&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt; &lt;span class="n"&gt;i&lt;/span&gt; &lt;span class="o"&gt;&amp;lt;&lt;/span&gt; &lt;span class="mi"&gt;100&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt; &lt;span class="n"&gt;i&lt;/span&gt;&lt;span class="o"&gt;++&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt; &lt;span class="p"&gt;{&lt;/span&gt;
            &lt;span class="n"&gt;System&lt;/span&gt;&lt;span class="p"&gt;.&lt;/span&gt;&lt;span class="na"&gt;out&lt;/span&gt;&lt;span class="p"&gt;.&lt;/span&gt;&lt;span class="na"&gt;println&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;getName&lt;/span&gt;&lt;span class="p"&gt;()&lt;/span&gt;&lt;span class="o"&gt;+&lt;/span&gt;&lt;span class="s"&gt;&amp;quot;线程开启了&amp;quot;&lt;/span&gt; &lt;span class="o"&gt;+&lt;/span&gt; &lt;span class="n"&gt;i&lt;/span&gt;&lt;span class="p"&gt;);&lt;/span&gt;
        &lt;span class="p"&gt;}&lt;/span&gt;
    &lt;span class="p"&gt;}&lt;/span&gt;
&lt;span class="p"&gt;}&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;&lt;span class="kd"&gt;public&lt;/span&gt; &lt;span class="kd"&gt;class&lt;/span&gt; &lt;span class="nc"&gt;MyThreadTest&lt;/span&gt; &lt;span class="p"&gt;{&lt;/span&gt;
    &lt;span class="kd"&gt;public&lt;/span&gt; &lt;span class="kd"&gt;static&lt;/span&gt; &lt;span class="kt"&gt;void&lt;/span&gt; &lt;span class="nf"&gt;main&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;String&lt;/span&gt;&lt;span class="o"&gt;[]&lt;/span&gt; &lt;span class="n"&gt;args&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt; &lt;span class="p"&gt;{&lt;/span&gt;
        &lt;span class="n"&gt;MyThread&lt;/span&gt; &lt;span class="n"&gt;t1&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="k"&gt;new&lt;/span&gt; &lt;span class="n"&gt;MyThread&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="s"&gt;&amp;quot;小明&amp;quot;&lt;/span&gt;&lt;span class="p"&gt;);&lt;/span&gt;
        &lt;span class="n"&gt;MyThread&lt;/span&gt; &lt;span class="n"&gt;t2&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="k"&gt;new&lt;/span&gt; &lt;span class="n"&gt;MyThread&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="s"&gt;&amp;quot;小红&amp;quot;&lt;/span&gt;&lt;span class="p"&gt;);&lt;/span&gt;

&lt;span class="c1"&gt;//        使用setName()&lt;/span&gt;
&lt;span class="c1"&gt;//        t1.setName(&amp;quot;小明&amp;quot;);&lt;/span&gt;
&lt;span class="c1"&gt;//        t2.setName(&amp;quot;小红&amp;quot;);&lt;/span&gt;

        &lt;span class="n"&gt;t1&lt;/span&gt;&lt;span class="p"&gt;.&lt;/span&gt;&lt;span class="na"&gt;start&lt;/span&gt;&lt;span class="p"&gt;();&lt;/span&gt;
        &lt;span class="n"&gt;t2&lt;/span&gt;&lt;span class="p"&gt;.&lt;/span&gt;&lt;span class="na"&gt;start&lt;/span&gt;&lt;span class="p"&gt;();&lt;/span&gt;
    &lt;span class="p"&gt;}&lt;/span&gt;
&lt;span class="p"&gt;}&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;注意：线程是有默认名字的，为Thread-编号&lt;/p&gt;
&lt;h2&gt;获取当前线程的对象&lt;/h2&gt;
&lt;ul&gt;
&lt;li&gt;public static Thread currentThread() ：返回当前正在执行的线程对象的引用&lt;/li&gt;
&lt;li&gt;作用：当使用 实现Runnable 创建线程时，不可以直接使用getName()，此时应该用 Thread.currentThread().getName()&lt;/li&gt;
&lt;/ul&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;&lt;span class="kd"&gt;public&lt;/span&gt; &lt;span class="kd"&gt;class&lt;/span&gt; &lt;span class="nc"&gt;MyRunnable&lt;/span&gt; &lt;span class="kd"&gt;implements&lt;/span&gt; &lt;span class="n"&gt;Runnable&lt;/span&gt; &lt;span class="p"&gt;{&lt;/span&gt;
    &lt;span class="nd"&gt;@Override&lt;/span&gt;
    &lt;span class="kd"&gt;public&lt;/span&gt; &lt;span class="kt"&gt;void&lt;/span&gt; &lt;span class="nf"&gt;run&lt;/span&gt;&lt;span class="p"&gt;()&lt;/span&gt; &lt;span class="p"&gt;{&lt;/span&gt;
        &lt;span class="k"&gt;for&lt;/span&gt; &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="kt"&gt;int&lt;/span&gt; &lt;span class="n"&gt;i&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="mi"&gt;0&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt; &lt;span class="n"&gt;i&lt;/span&gt; &lt;span class="o"&gt;&amp;lt;&lt;/span&gt; &lt;span class="mi"&gt;100&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt; &lt;span class="n"&gt;i&lt;/span&gt;&lt;span class="o"&gt;++&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt; &lt;span class="p"&gt;{&lt;/span&gt;
            &lt;span class="n"&gt;System&lt;/span&gt;&lt;span class="p"&gt;.&lt;/span&gt;&lt;span class="na"&gt;out&lt;/span&gt;&lt;span class="p"&gt;.&lt;/span&gt;&lt;span class="na"&gt;println&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;Thread&lt;/span&gt;&lt;span class="p"&gt;.&lt;/span&gt;&lt;span class="na"&gt;currentThread&lt;/span&gt;&lt;span class="p"&gt;().&lt;/span&gt;&lt;span class="na"&gt;getName&lt;/span&gt;&lt;span class="p"&gt;()&lt;/span&gt;&lt;span class="o"&gt;+&lt;/span&gt;&lt;span class="s"&gt;&amp;quot;第二种方式&amp;quot;&lt;/span&gt;&lt;span class="o"&gt;+&lt;/span&gt;&lt;span class="n"&gt;i&lt;/span&gt;&lt;span class="p"&gt;);&lt;/span&gt;
        &lt;span class="p"&gt;}&lt;/span&gt;
    &lt;span class="p"&gt;}&lt;/span&gt;
&lt;span class="p"&gt;}&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;h2&gt;线程休眠&lt;/h2&gt;
&lt;ul&gt;
&lt;li&gt;public static void sleep(long time) ：让线程休眠指定的时间，单位为毫秒。 &lt;/li&gt;
&lt;/ul&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;&lt;span class="nd"&gt;@Override&lt;/span&gt;
    &lt;span class="kd"&gt;public&lt;/span&gt; &lt;span class="kt"&gt;void&lt;/span&gt; &lt;span class="nf"&gt;run&lt;/span&gt;&lt;span class="p"&gt;()&lt;/span&gt; &lt;span class="p"&gt;{&lt;/span&gt;
        &lt;span class="k"&gt;while&lt;/span&gt; &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="kc"&gt;true&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt; &lt;span class="p"&gt;{&lt;/span&gt;
            &lt;span class="k"&gt;try&lt;/span&gt; &lt;span class="p"&gt;{&lt;/span&gt;
                &lt;span class="c1"&gt;//线程休眠&lt;/span&gt;
                &lt;span class="n"&gt;Thread&lt;/span&gt;&lt;span class="p"&gt;.&lt;/span&gt;&lt;span class="na"&gt;sleep&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="mi"&gt;800&lt;/span&gt;&lt;span class="p"&gt;);&lt;/span&gt;
                &lt;span class="n"&gt;System&lt;/span&gt;&lt;span class="p"&gt;.&lt;/span&gt;&lt;span class="na"&gt;out&lt;/span&gt;&lt;span class="p"&gt;.&lt;/span&gt;&lt;span class="na"&gt;println&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="s"&gt;&amp;quot; ----First Thread----&amp;quot;&lt;/span&gt;&lt;span class="p"&gt;);&lt;/span&gt;
            &lt;span class="p"&gt;}&lt;/span&gt; &lt;span class="k"&gt;catch&lt;/span&gt; &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;InterruptedException&lt;/span&gt; &lt;span class="n"&gt;e&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt; &lt;span class="p"&gt;{&lt;/span&gt;
                &lt;span class="n"&gt;e&lt;/span&gt;&lt;span class="p"&gt;.&lt;/span&gt;&lt;span class="na"&gt;printStackTrace&lt;/span&gt;&lt;span class="p"&gt;();&lt;/span&gt;
            &lt;span class="p"&gt;}&lt;/span&gt;
        &lt;span class="p"&gt;}&lt;/span&gt;
    &lt;span class="p"&gt;}&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;h2&gt;后台线程/守护线程&lt;/h2&gt;
&lt;ul&gt;
&lt;li&gt;当线程停止时，守护线程也随之停止。&lt;/li&gt;
&lt;li&gt;public final void sedDaemon(boolean on) ：设置为守护线程&lt;/li&gt;
&lt;/ul&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;&lt;span class="kd"&gt;public&lt;/span&gt; &lt;span class="kd"&gt;class&lt;/span&gt; &lt;span class="nc"&gt;test&lt;/span&gt; &lt;span class="p"&gt;{&lt;/span&gt;
    &lt;span class="kd"&gt;public&lt;/span&gt; &lt;span class="kd"&gt;static&lt;/span&gt; &lt;span class="kt"&gt;void&lt;/span&gt; &lt;span class="nf"&gt;main&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;String&lt;/span&gt;&lt;span class="o"&gt;[]&lt;/span&gt; &lt;span class="n"&gt;args&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt; &lt;span class="p"&gt;{&lt;/span&gt;
        &lt;span class="n"&gt;Runnable1&lt;/span&gt; &lt;span class="n"&gt;runnable1&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="k"&gt;new&lt;/span&gt; &lt;span class="n"&gt;Runnable1&lt;/span&gt;&lt;span class="p"&gt;();&lt;/span&gt;
        &lt;span class="n"&gt;Runnable2&lt;/span&gt; &lt;span class="n"&gt;runnable2&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="k"&gt;new&lt;/span&gt; &lt;span class="n"&gt;Runnable2&lt;/span&gt;&lt;span class="p"&gt;();&lt;/span&gt;

        &lt;span class="n"&gt;Thread&lt;/span&gt; &lt;span class="n"&gt;thread1&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="k"&gt;new&lt;/span&gt; &lt;span class="n"&gt;Thread&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;runnable1&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt;&lt;span class="s"&gt;&amp;quot;线程一&amp;quot;&lt;/span&gt;&lt;span class="p"&gt;);&lt;/span&gt;
        &lt;span class="n"&gt;Thread&lt;/span&gt; &lt;span class="n"&gt;thread2&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="k"&gt;new&lt;/span&gt; &lt;span class="n"&gt;Thread&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;runnable2&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt;&lt;span class="s"&gt;&amp;quot;线程二&amp;quot;&lt;/span&gt;&lt;span class="p"&gt;);&lt;/span&gt;

&lt;span class="c1"&gt;//        设置线程二为守护线程&lt;/span&gt;
        &lt;span class="n"&gt;thread2&lt;/span&gt;&lt;span class="p"&gt;.&lt;/span&gt;&lt;span class="na"&gt;setDaemon&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="kc"&gt;true&lt;/span&gt;&lt;span class="p"&gt;);&lt;/span&gt;
        &lt;span class="n"&gt;thread1&lt;/span&gt;&lt;span class="p"&gt;.&lt;/span&gt;&lt;span class="na"&gt;start&lt;/span&gt;&lt;span class="p"&gt;();&lt;/span&gt;
        &lt;span class="n"&gt;thread2&lt;/span&gt;&lt;span class="p"&gt;.&lt;/span&gt;&lt;span class="na"&gt;start&lt;/span&gt;&lt;span class="p"&gt;();&lt;/span&gt;
    &lt;span class="p"&gt;}&lt;/span&gt;
&lt;span class="p"&gt;}&lt;/span&gt;

&lt;span class="kd"&gt;class&lt;/span&gt; &lt;span class="nc"&gt;Runnable1&lt;/span&gt; &lt;span class="kd"&gt;implements&lt;/span&gt; &lt;span class="n"&gt;Runnable&lt;/span&gt;&lt;span class="p"&gt;{&lt;/span&gt;

    &lt;span class="nd"&gt;@Override&lt;/span&gt;
    &lt;span class="kd"&gt;public&lt;/span&gt; &lt;span class="kt"&gt;void&lt;/span&gt; &lt;span class="nf"&gt;run&lt;/span&gt;&lt;span class="p"&gt;()&lt;/span&gt; &lt;span class="p"&gt;{&lt;/span&gt;
        &lt;span class="k"&gt;for&lt;/span&gt; &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="kt"&gt;int&lt;/span&gt; &lt;span class="n"&gt;i&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="mi"&gt;0&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt; &lt;span class="n"&gt;i&lt;/span&gt; &lt;span class="o"&gt;&amp;lt;&lt;/span&gt; &lt;span class="mi"&gt;10&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt; &lt;span class="n"&gt;i&lt;/span&gt;&lt;span class="o"&gt;++&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt; &lt;span class="p"&gt;{&lt;/span&gt;
            &lt;span class="n"&gt;System&lt;/span&gt;&lt;span class="p"&gt;.&lt;/span&gt;&lt;span class="na"&gt;out&lt;/span&gt;&lt;span class="p"&gt;.&lt;/span&gt;&lt;span class="na"&gt;println&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;Thread&lt;/span&gt;&lt;span class="p"&gt;.&lt;/span&gt;&lt;span class="na"&gt;currentThread&lt;/span&gt;&lt;span class="p"&gt;().&lt;/span&gt;&lt;span class="na"&gt;getName&lt;/span&gt;&lt;span class="p"&gt;()&lt;/span&gt;&lt;span class="o"&gt;+&lt;/span&gt;&lt;span class="s"&gt;&amp;quot;执行了&amp;quot;&lt;/span&gt;&lt;span class="o"&gt;+&lt;/span&gt;&lt;span class="n"&gt;i&lt;/span&gt;&lt;span class="p"&gt;);&lt;/span&gt;
        &lt;span class="p"&gt;}&lt;/span&gt;
    &lt;span class="p"&gt;}&lt;/span&gt;
&lt;span class="p"&gt;}&lt;/span&gt;

&lt;span class="kd"&gt;class&lt;/span&gt; &lt;span class="nc"&gt;Runnable2&lt;/span&gt; &lt;span class="kd"&gt;implements&lt;/span&gt; &lt;span class="n"&gt;Runnable&lt;/span&gt;&lt;span class="p"&gt;{&lt;/span&gt;

    &lt;span class="nd"&gt;@Override&lt;/span&gt;
    &lt;span class="kd"&gt;public&lt;/span&gt; &lt;span class="kt"&gt;void&lt;/span&gt; &lt;span class="nf"&gt;run&lt;/span&gt;&lt;span class="p"&gt;()&lt;/span&gt; &lt;span class="p"&gt;{&lt;/span&gt;
        &lt;span class="k"&gt;for&lt;/span&gt; &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="kt"&gt;int&lt;/span&gt; &lt;span class="n"&gt;i&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="mi"&gt;0&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt; &lt;span class="n"&gt;i&lt;/span&gt; &lt;span class="o"&gt;&amp;lt;&lt;/span&gt; &lt;span class="mi"&gt;100&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt; &lt;span class="n"&gt;i&lt;/span&gt;&lt;span class="o"&gt;++&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt; &lt;span class="p"&gt;{&lt;/span&gt;
            &lt;span class="n"&gt;System&lt;/span&gt;&lt;span class="p"&gt;.&lt;/span&gt;&lt;span class="na"&gt;out&lt;/span&gt;&lt;span class="p"&gt;.&lt;/span&gt;&lt;span class="na"&gt;println&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;Thread&lt;/span&gt;&lt;span class="p"&gt;.&lt;/span&gt;&lt;span class="na"&gt;currentThread&lt;/span&gt;&lt;span class="p"&gt;().&lt;/span&gt;&lt;span class="na"&gt;getName&lt;/span&gt;&lt;span class="p"&gt;()&lt;/span&gt;&lt;span class="o"&gt;+&lt;/span&gt;&lt;span class="s"&gt;&amp;quot;执行了&amp;quot;&lt;/span&gt;&lt;span class="o"&gt;+&lt;/span&gt;&lt;span class="n"&gt;i&lt;/span&gt;&lt;span class="p"&gt;);&lt;/span&gt;
        &lt;span class="p"&gt;}&lt;/span&gt;
    &lt;span class="p"&gt;}&lt;/span&gt;
&lt;span class="p"&gt;}&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;h2&gt;线程调度多线程的并发运行：&lt;/h2&gt;
&lt;p&gt;计算机中的CPU，在任意时刻只能执行一条机器指令。每个线程只有获得CPU的使用权才能执行代码。各个线程轮流获得CPU的使用校，分别执行各自的任务。&lt;/p&gt;
&lt;h2&gt;线程调度&lt;/h2&gt;
&lt;p&gt;线程有两种调度模型·分时调度模型：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;所有线程轮流使用CPU的使用权，平均分配每个线程占用CPU的时间片&lt;/li&gt;
&lt;li&gt;抢占式调度模型：优先让优先级高的线程使用CPU，如果线程的优先级相同，那么会雕机选择一个，优先级高的线程获取的CPU时间片相对多一些&lt;/li&gt;
&lt;li&gt;Java使用的是抢占式调度模型&lt;/li&gt;
&lt;/ul&gt;
&lt;h2&gt;线程的优先级&lt;/h2&gt;
&lt;ul&gt;
&lt;li&gt;public final void setPriority(int newPriority)    设置线程的优先级&lt;/li&gt;
&lt;li&gt;public  final int getPriority()   获取线程的优先级&lt;/li&gt;
&lt;li&gt;线程的优先级1-10，默认为5&lt;/li&gt;
&lt;li&gt;优先级更高，抢夺到cpu执行权的机率更高，但仅仅只是机率。&lt;/li&gt;
&lt;/ul&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;&lt;span class="kd"&gt;public&lt;/span&gt; &lt;span class="kd"&gt;class&lt;/span&gt; &lt;span class="nc"&gt;RunnableTest&lt;/span&gt; &lt;span class="p"&gt;{&lt;/span&gt;
    &lt;span class="kd"&gt;public&lt;/span&gt; &lt;span class="kd"&gt;static&lt;/span&gt; &lt;span class="kt"&gt;void&lt;/span&gt; &lt;span class="nf"&gt;main&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;String&lt;/span&gt;&lt;span class="o"&gt;[]&lt;/span&gt; &lt;span class="n"&gt;args&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt; &lt;span class="p"&gt;{&lt;/span&gt;
        &lt;span class="n"&gt;MyRunnable1&lt;/span&gt; &lt;span class="n"&gt;runnable1&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="k"&gt;new&lt;/span&gt; &lt;span class="n"&gt;MyRunnable1&lt;/span&gt;&lt;span class="p"&gt;();&lt;/span&gt;
        &lt;span class="n"&gt;MyRunnable2&lt;/span&gt; &lt;span class="n"&gt;runnable2&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="k"&gt;new&lt;/span&gt; &lt;span class="n"&gt;MyRunnable2&lt;/span&gt;&lt;span class="p"&gt;();&lt;/span&gt;
        &lt;span class="n"&gt;Thread&lt;/span&gt; &lt;span class="n"&gt;thread1&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="k"&gt;new&lt;/span&gt; &lt;span class="n"&gt;Thread&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;runnable1&lt;/span&gt;&lt;span class="p"&gt;);&lt;/span&gt;
        &lt;span class="n"&gt;Thread&lt;/span&gt; &lt;span class="n"&gt;thread2&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="k"&gt;new&lt;/span&gt; &lt;span class="n"&gt;Thread&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;runnable2&lt;/span&gt;&lt;span class="p"&gt;);&lt;/span&gt;

        &lt;span class="c1"&gt;//设置线程优先级&lt;/span&gt;
        &lt;span class="n"&gt;thread1&lt;/span&gt;&lt;span class="p"&gt;.&lt;/span&gt;&lt;span class="na"&gt;setPriority&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="mi"&gt;8&lt;/span&gt;&lt;span class="p"&gt;);&lt;/span&gt;
        &lt;span class="n"&gt;thread2&lt;/span&gt;&lt;span class="p"&gt;.&lt;/span&gt;&lt;span class="na"&gt;setPriority&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="mi"&gt;1&lt;/span&gt;&lt;span class="p"&gt;);&lt;/span&gt;

        &lt;span class="c1"&gt;//打印出线程一的优先级,不设置时默认为5&lt;/span&gt;
        &lt;span class="n"&gt;System&lt;/span&gt;&lt;span class="p"&gt;.&lt;/span&gt;&lt;span class="na"&gt;out&lt;/span&gt;&lt;span class="p"&gt;.&lt;/span&gt;&lt;span class="na"&gt;println&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;thread1&lt;/span&gt;&lt;span class="p"&gt;.&lt;/span&gt;&lt;span class="na"&gt;getPriority&lt;/span&gt;&lt;span class="p"&gt;());&lt;/span&gt;

        &lt;span class="n"&gt;thread1&lt;/span&gt;&lt;span class="p"&gt;.&lt;/span&gt;&lt;span class="na"&gt;start&lt;/span&gt;&lt;span class="p"&gt;();&lt;/span&gt;
        &lt;span class="n"&gt;thread2&lt;/span&gt;&lt;span class="p"&gt;.&lt;/span&gt;&lt;span class="na"&gt;start&lt;/span&gt;&lt;span class="p"&gt;();&lt;/span&gt;
    &lt;span class="p"&gt;}&lt;/span&gt;
&lt;span class="p"&gt;}&lt;/span&gt;

&lt;span class="kd"&gt;class&lt;/span&gt; &lt;span class="nc"&gt;MyRunnable1&lt;/span&gt; &lt;span class="kd"&gt;implements&lt;/span&gt; &lt;span class="n"&gt;Runnable&lt;/span&gt; &lt;span class="p"&gt;{&lt;/span&gt;
    &lt;span class="nd"&gt;@Override&lt;/span&gt;
    &lt;span class="kd"&gt;public&lt;/span&gt; &lt;span class="kt"&gt;void&lt;/span&gt; &lt;span class="nf"&gt;run&lt;/span&gt;&lt;span class="p"&gt;()&lt;/span&gt; &lt;span class="p"&gt;{&lt;/span&gt;
        &lt;span class="k"&gt;while&lt;/span&gt; &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="kc"&gt;true&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt; &lt;span class="p"&gt;{&lt;/span&gt;
            &lt;span class="k"&gt;try&lt;/span&gt; &lt;span class="p"&gt;{&lt;/span&gt;
                &lt;span class="c1"&gt;//线程休眠&lt;/span&gt;
                &lt;span class="n"&gt;Thread&lt;/span&gt;&lt;span class="p"&gt;.&lt;/span&gt;&lt;span class="na"&gt;sleep&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="mi"&gt;800&lt;/span&gt;&lt;span class="p"&gt;);&lt;/span&gt;
                &lt;span class="n"&gt;System&lt;/span&gt;&lt;span class="p"&gt;.&lt;/span&gt;&lt;span class="na"&gt;out&lt;/span&gt;&lt;span class="p"&gt;.&lt;/span&gt;&lt;span class="na"&gt;println&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="s"&gt;&amp;quot; ----First Thread----&amp;quot;&lt;/span&gt;&lt;span class="p"&gt;);&lt;/span&gt;
            &lt;span class="p"&gt;}&lt;/span&gt; &lt;span class="k"&gt;catch&lt;/span&gt; &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;InterruptedException&lt;/span&gt; &lt;span class="n"&gt;e&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt; &lt;span class="p"&gt;{&lt;/span&gt;
                &lt;span class="n"&gt;e&lt;/span&gt;&lt;span class="p"&gt;.&lt;/span&gt;&lt;span class="na"&gt;printStackTrace&lt;/span&gt;&lt;span class="p"&gt;();&lt;/span&gt;
            &lt;span class="p"&gt;}&lt;/span&gt;
        &lt;span class="p"&gt;}&lt;/span&gt;
    &lt;span class="p"&gt;}&lt;/span&gt;
&lt;span class="p"&gt;}&lt;/span&gt;

&lt;span class="kd"&gt;class&lt;/span&gt; &lt;span class="nc"&gt;MyRunnable2&lt;/span&gt; &lt;span class="kd"&gt;implements&lt;/span&gt; &lt;span class="n"&gt;Runnable&lt;/span&gt; &lt;span class="p"&gt;{&lt;/span&gt;
    &lt;span class="nd"&gt;@Override&lt;/span&gt;
    &lt;span class="kd"&gt;public&lt;/span&gt; &lt;span class="kt"&gt;void&lt;/span&gt; &lt;span class="nf"&gt;run&lt;/span&gt;&lt;span class="p"&gt;()&lt;/span&gt; &lt;span class="p"&gt;{&lt;/span&gt;
        &lt;span class="k"&gt;while&lt;/span&gt; &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="kc"&gt;true&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt; &lt;span class="p"&gt;{&lt;/span&gt;
            &lt;span class="k"&gt;try&lt;/span&gt; &lt;span class="p"&gt;{&lt;/span&gt;
                &lt;span class="c1"&gt;//线程休眠&lt;/span&gt;
                &lt;span class="n"&gt;Thread&lt;/span&gt;&lt;span class="p"&gt;.&lt;/span&gt;&lt;span class="na"&gt;sleep&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="mi"&gt;1500&lt;/span&gt;&lt;span class="p"&gt;);&lt;/span&gt;
                &lt;span class="n"&gt;System&lt;/span&gt;&lt;span class="p"&gt;.&lt;/span&gt;&lt;span class="na"&gt;out&lt;/span&gt;&lt;span class="p"&gt;.&lt;/span&gt;&lt;span class="na"&gt;println&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="s"&gt;&amp;quot; ----Second Thread----&amp;quot;&lt;/span&gt;&lt;span class="p"&gt;);&lt;/span&gt;
            &lt;span class="p"&gt;}&lt;/span&gt; &lt;span class="k"&gt;catch&lt;/span&gt; &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;InterruptedException&lt;/span&gt; &lt;span class="n"&gt;e&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt; &lt;span class="p"&gt;{&lt;/span&gt;
                &lt;span class="n"&gt;e&lt;/span&gt;&lt;span class="p"&gt;.&lt;/span&gt;&lt;span class="na"&gt;printStackTrace&lt;/span&gt;&lt;span class="p"&gt;();&lt;/span&gt;
            &lt;span class="p"&gt;}&lt;/span&gt;
        &lt;span class="p"&gt;}&lt;/span&gt;
    &lt;span class="p"&gt;}&lt;/span&gt;
&lt;span class="p"&gt;}&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;h2&gt;线程生命周期&lt;/h2&gt;
&lt;p&gt;&lt;figure&gt;&lt;img data-width="1049" data-height="381" src="https://cdn.xn2001.com/2020/01/1809456008.png#vwid=1049&amp;vhei=381" alt="" /&gt;&lt;/figure&gt;&lt;/p&gt;
</description><author>jialna@qq.com (乐心湖)</author><guid isPermaLink="true">/archives/thread-void-java/</guid><pubDate>Mon, 09 Mar 2020 13:10:00 +0806</pubDate></item><item><title>Java多线程的安全问题</title><link>/archives/thread-safe-java/</link><description>&lt;h1&gt;线程的安全问题&lt;/h1&gt;
&lt;h2&gt;案例&lt;/h2&gt;
&lt;p&gt;&lt;strong&gt;需求&lt;/strong&gt; ：某电影院目前正在上映国产大片，共有100张票，而他有3个窗口卖票，请设计一个程序模拟该电影院卖票&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;思路&lt;/strong&gt; ：&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;&lt;p&gt;定义一个类Ticket实现Runnable接口，里面定义一个成员变量：
&lt;code&gt;private int ticketCount = 100;&lt;/code&gt;&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;&lt;p&gt;在Ticket类中重写run()方法实现卖票，步骤如下：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;判断票数如果大于0，就卖票，并告知哪个窗口购买&lt;/li&gt;
&lt;li&gt;票数自动减一&lt;/li&gt;
&lt;li&gt;卖光之后，线程停止&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;&lt;p&gt;定义一个测试类TicketDemo，步骤如下：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;创建Ticket类的对象&lt;/li&gt;
&lt;li&gt;创建三个Thread类的对象，把Ticket对象作为构造方法的参数，并给出对应的窗口名称&lt;/li&gt;
&lt;li&gt;启动线程&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ol&gt;
&lt;h2&gt;代码实现&lt;/h2&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;&lt;span class="kd"&gt;public&lt;/span&gt; &lt;span class="kd"&gt;class&lt;/span&gt; &lt;span class="nc"&gt;Ticket&lt;/span&gt; &lt;span class="kd"&gt;implements&lt;/span&gt; &lt;span class="n"&gt;Runnable&lt;/span&gt; &lt;span class="p"&gt;{&lt;/span&gt;

    &lt;span class="kd"&gt;private&lt;/span&gt; &lt;span class="kt"&gt;int&lt;/span&gt; &lt;span class="n"&gt;ticketCount&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="mi"&gt;100&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;

    &lt;span class="nd"&gt;@Override&lt;/span&gt;
    &lt;span class="kd"&gt;public&lt;/span&gt; &lt;span class="kt"&gt;void&lt;/span&gt; &lt;span class="nf"&gt;run&lt;/span&gt;&lt;span class="p"&gt;()&lt;/span&gt; &lt;span class="p"&gt;{&lt;/span&gt;
        &lt;span class="k"&gt;while&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="kc"&gt;true&lt;/span&gt;&lt;span class="p"&gt;){&lt;/span&gt;
            &lt;span class="k"&gt;if&lt;/span&gt; &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;ticketCount&lt;/span&gt;&lt;span class="o"&gt;&amp;lt;=&lt;/span&gt;&lt;span class="mi"&gt;0&lt;/span&gt;&lt;span class="p"&gt;){&lt;/span&gt;
                &lt;span class="k"&gt;break&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;
            &lt;span class="p"&gt;}&lt;/span&gt;&lt;span class="k"&gt;else&lt;/span&gt;&lt;span class="p"&gt;{&lt;/span&gt;
                &lt;span class="k"&gt;this&lt;/span&gt;&lt;span class="p"&gt;.&lt;/span&gt;&lt;span class="na"&gt;ticketCount&lt;/span&gt; &lt;span class="o"&gt;-=&lt;/span&gt; &lt;span class="mi"&gt;1&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;
                &lt;span class="n"&gt;System&lt;/span&gt;&lt;span class="p"&gt;.&lt;/span&gt;&lt;span class="na"&gt;out&lt;/span&gt;&lt;span class="p"&gt;.&lt;/span&gt;&lt;span class="na"&gt;println&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;Thread&lt;/span&gt;&lt;span class="p"&gt;.&lt;/span&gt;&lt;span class="na"&gt;currentThread&lt;/span&gt;&lt;span class="p"&gt;().&lt;/span&gt;&lt;span class="na"&gt;getName&lt;/span&gt;&lt;span class="p"&gt;()&lt;/span&gt;&lt;span class="o"&gt;+&lt;/span&gt;&lt;span class="s"&gt;&amp;quot;正在卖票,还剩有&amp;quot;&lt;/span&gt;&lt;span class="o"&gt;+&lt;/span&gt;&lt;span class="k"&gt;this&lt;/span&gt;&lt;span class="p"&gt;.&lt;/span&gt;&lt;span class="na"&gt;ticketCount&lt;/span&gt;&lt;span class="o"&gt;+&lt;/span&gt;&lt;span class="s"&gt;&amp;quot;张&amp;quot;&lt;/span&gt;&lt;span class="p"&gt;);&lt;/span&gt;
            &lt;span class="p"&gt;}&lt;/span&gt;
        &lt;span class="p"&gt;}&lt;/span&gt;
    &lt;span class="p"&gt;}&lt;/span&gt;
&lt;span class="p"&gt;}&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;&lt;span class="kd"&gt;public&lt;/span&gt; &lt;span class="kd"&gt;class&lt;/span&gt; &lt;span class="nc"&gt;Demo&lt;/span&gt; &lt;span class="p"&gt;{&lt;/span&gt;
    &lt;span class="kd"&gt;public&lt;/span&gt; &lt;span class="kd"&gt;static&lt;/span&gt; &lt;span class="kt"&gt;void&lt;/span&gt; &lt;span class="nf"&gt;main&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;String&lt;/span&gt;&lt;span class="o"&gt;[]&lt;/span&gt; &lt;span class="n"&gt;args&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt; &lt;span class="p"&gt;{&lt;/span&gt;
        &lt;span class="n"&gt;Ticket&lt;/span&gt; &lt;span class="n"&gt;ticket&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="k"&gt;new&lt;/span&gt; &lt;span class="n"&gt;Ticket&lt;/span&gt;&lt;span class="p"&gt;();&lt;/span&gt;
        &lt;span class="n"&gt;Thread&lt;/span&gt; &lt;span class="n"&gt;t1&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="k"&gt;new&lt;/span&gt; &lt;span class="n"&gt;Thread&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;ticket&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt;&lt;span class="s"&gt;&amp;quot;一号窗口&amp;quot;&lt;/span&gt;&lt;span class="p"&gt;);&lt;/span&gt;
        &lt;span class="n"&gt;Thread&lt;/span&gt; &lt;span class="n"&gt;t2&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="k"&gt;new&lt;/span&gt; &lt;span class="n"&gt;Thread&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;ticket&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt;&lt;span class="s"&gt;&amp;quot;二号窗口&amp;quot;&lt;/span&gt;&lt;span class="p"&gt;);&lt;/span&gt;
        &lt;span class="n"&gt;Thread&lt;/span&gt; &lt;span class="n"&gt;t3&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="k"&gt;new&lt;/span&gt; &lt;span class="n"&gt;Thread&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;ticket&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt;&lt;span class="s"&gt;&amp;quot;三号窗口&amp;quot;&lt;/span&gt;&lt;span class="p"&gt;);&lt;/span&gt;
        &lt;span class="n"&gt;t1&lt;/span&gt;&lt;span class="p"&gt;.&lt;/span&gt;&lt;span class="na"&gt;start&lt;/span&gt;&lt;span class="p"&gt;();&lt;/span&gt;
        &lt;span class="n"&gt;t2&lt;/span&gt;&lt;span class="p"&gt;.&lt;/span&gt;&lt;span class="na"&gt;start&lt;/span&gt;&lt;span class="p"&gt;();&lt;/span&gt;
        &lt;span class="n"&gt;t3&lt;/span&gt;&lt;span class="p"&gt;.&lt;/span&gt;&lt;span class="na"&gt;start&lt;/span&gt;&lt;span class="p"&gt;();&lt;/span&gt;
    &lt;span class="p"&gt;}&lt;/span&gt;
&lt;span class="p"&gt;}&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;h2&gt;卖票案例的思考&lt;/h2&gt;
&lt;p&gt;看似这个案例没有什么问题,但是在实际生活中,售票时候出票是需要一定的时间的,所以在出售一张票的时候需要一点时间的延迟,接下来就修改卖票程序中的动作,每次出票时间为100毫秒,用sleep()方法实现。&lt;/p&gt;
&lt;p&gt;此时出现了问题&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;相同的票出现了多次&lt;/li&gt;
&lt;li&gt;出现的负数的票&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;为什么出现这个问题（这也是我们判断多线程程序是否会有数据安全问题的标准）&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;多线程操作共享数据&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;如果解决多线程安全问题？&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;基本思想：让程序没有安全问题的环境&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;实现方法&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;把多条语句操作共享数据的代码&lt;strong&gt;锁&lt;/strong&gt;起来，让任意时刻只能有一个先吃执行。&lt;/li&gt;
&lt;/ul&gt;
&lt;h2&gt;同步代码块&lt;/h2&gt;
&lt;p&gt;锁多条语句操作共享数据，可以使用同步代码块实现&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;p&gt;格式：&lt;/p&gt;
&lt;p&gt;synchronized(任意对象){ 多条语句操作共享数据的代码 }&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;&lt;p&gt;默认情况是打开的，只要有一个线程进去执行代码了，锁就会关闭。&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;&lt;p&gt;当线程执行完了之后，锁就会自动打开。&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;同步的好处和弊端&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;好处：解决了多线程的数据安全问题&lt;/li&gt;
&lt;li&gt;弊端：当线程很多时，因为每个线程都会去&lt;strong&gt;判断&lt;/strong&gt;同步上的锁，这是非常浪费资源的，无形中降低了程序的运行效率&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;下面我们更新一下Ticket类。&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;&lt;span class="kd"&gt;public&lt;/span&gt; &lt;span class="kd"&gt;class&lt;/span&gt; &lt;span class="nc"&gt;Ticket&lt;/span&gt; &lt;span class="kd"&gt;implements&lt;/span&gt; &lt;span class="n"&gt;Runnable&lt;/span&gt; &lt;span class="p"&gt;{&lt;/span&gt;

    &lt;span class="kd"&gt;private&lt;/span&gt; &lt;span class="kt"&gt;int&lt;/span&gt; &lt;span class="n"&gt;ticketCount&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="mi"&gt;100&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;
    &lt;span class="kd"&gt;private&lt;/span&gt; &lt;span class="n"&gt;Object&lt;/span&gt; &lt;span class="n"&gt;o&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="k"&gt;new&lt;/span&gt; &lt;span class="n"&gt;Object&lt;/span&gt;&lt;span class="p"&gt;();&lt;/span&gt;

    &lt;span class="nd"&gt;@Override&lt;/span&gt;
    &lt;span class="kd"&gt;public&lt;/span&gt; &lt;span class="kt"&gt;void&lt;/span&gt; &lt;span class="nf"&gt;run&lt;/span&gt;&lt;span class="p"&gt;()&lt;/span&gt; &lt;span class="p"&gt;{&lt;/span&gt;
        &lt;span class="k"&gt;while&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="kc"&gt;true&lt;/span&gt;&lt;span class="p"&gt;){&lt;/span&gt;

            &lt;span class="c1"&gt;//锁对象,任意对象就可以.&lt;/span&gt;
            &lt;span class="c1"&gt;//多个线程必须使用同一把锁&lt;/span&gt;
            &lt;span class="kd"&gt;synchronized&lt;/span&gt; &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;o&lt;/span&gt;&lt;span class="p"&gt;){&lt;/span&gt;
                &lt;span class="k"&gt;if&lt;/span&gt; &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;ticketCount&lt;/span&gt;&lt;span class="o"&gt;==&lt;/span&gt;&lt;span class="mi"&gt;0&lt;/span&gt;&lt;span class="p"&gt;){&lt;/span&gt;
                    &lt;span class="k"&gt;break&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;
                &lt;span class="p"&gt;}&lt;/span&gt;&lt;span class="k"&gt;else&lt;/span&gt;&lt;span class="p"&gt;{&lt;/span&gt;
                    &lt;span class="k"&gt;try&lt;/span&gt; &lt;span class="p"&gt;{&lt;/span&gt;
                        &lt;span class="n"&gt;Thread&lt;/span&gt;&lt;span class="p"&gt;.&lt;/span&gt;&lt;span class="na"&gt;sleep&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="mi"&gt;100&lt;/span&gt;&lt;span class="p"&gt;);&lt;/span&gt;
                    &lt;span class="p"&gt;}&lt;/span&gt; &lt;span class="k"&gt;catch&lt;/span&gt; &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;InterruptedException&lt;/span&gt; &lt;span class="n"&gt;e&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt; &lt;span class="p"&gt;{&lt;/span&gt;
                        &lt;span class="n"&gt;e&lt;/span&gt;&lt;span class="p"&gt;.&lt;/span&gt;&lt;span class="na"&gt;printStackTrace&lt;/span&gt;&lt;span class="p"&gt;();&lt;/span&gt;
                    &lt;span class="p"&gt;}&lt;/span&gt;
                    &lt;span class="k"&gt;this&lt;/span&gt;&lt;span class="p"&gt;.&lt;/span&gt;&lt;span class="na"&gt;ticketCount&lt;/span&gt; &lt;span class="o"&gt;-=&lt;/span&gt; &lt;span class="mi"&gt;1&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;
                    &lt;span class="n"&gt;System&lt;/span&gt;&lt;span class="p"&gt;.&lt;/span&gt;&lt;span class="na"&gt;out&lt;/span&gt;&lt;span class="p"&gt;.&lt;/span&gt;&lt;span class="na"&gt;println&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;Thread&lt;/span&gt;&lt;span class="p"&gt;.&lt;/span&gt;&lt;span class="na"&gt;currentThread&lt;/span&gt;&lt;span class="p"&gt;().&lt;/span&gt;&lt;span class="na"&gt;getName&lt;/span&gt;&lt;span class="p"&gt;()&lt;/span&gt;&lt;span class="o"&gt;+&lt;/span&gt;&lt;span class="s"&gt;&amp;quot;正在卖票,还剩有&amp;quot;&lt;/span&gt;&lt;span class="o"&gt;+&lt;/span&gt;&lt;span class="k"&gt;this&lt;/span&gt;&lt;span class="p"&gt;.&lt;/span&gt;&lt;span class="na"&gt;ticketCount&lt;/span&gt;&lt;span class="o"&gt;+&lt;/span&gt;&lt;span class="s"&gt;&amp;quot;张&amp;quot;&lt;/span&gt;&lt;span class="p"&gt;);&lt;/span&gt;
                &lt;span class="p"&gt;}&lt;/span&gt;
            &lt;span class="p"&gt;}&lt;/span&gt;
        &lt;span class="p"&gt;}&lt;/span&gt;
    &lt;span class="p"&gt;}&lt;/span&gt;
&lt;span class="p"&gt;}&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;&lt;figure&gt;&lt;img data-width="546" data-height="352" src="https://cdn.xn2001.com/2020/02/05/20200205011342.png" alt="" /&gt;&lt;/figure&gt;&lt;/p&gt;
&lt;p&gt;此时的运行结果变得非常自然。&lt;/p&gt;
&lt;h3&gt;synchronized的锁对象必须是唯一的&lt;/h3&gt;
&lt;h2&gt;同步方法&lt;/h2&gt;
&lt;p&gt;同步方法：就是把&lt;code&gt;synchronized&lt;/code&gt;关键字加到方法上。&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;p&gt;格式：&lt;/p&gt;
&lt;p&gt;修饰符 synchronized 返回值类型 方法名(方法参数){ }&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;同步静态方法：就是把synchronized关键词加到静态方法上&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;p&gt;格式：&lt;/p&gt;
&lt;p&gt;修饰符 static synchronized 返回值类型 方法名(方法参数){ }&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;主要记住：&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;&lt;p&gt;同步方法到底锁对象是什么？ &lt;strong&gt;this&lt;/strong&gt;&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;&lt;p&gt;同步静态方法的锁对象是什么？ &lt;strong&gt;类名.class&lt;/strong&gt;&lt;/p&gt;
&lt;/li&gt;
&lt;/ol&gt;
&lt;h2&gt;同步代码块和同步方法的区别&lt;/h2&gt;
&lt;ul&gt;
&lt;li&gt;同步代码块可以锁住指定代码，同步方法是锁住方法中所有代码。&lt;/li&gt;
&lt;li&gt;同步代码块可以指定锁对象，同步方法不能&lt;strong&gt;指定&lt;/strong&gt;锁对象。&lt;/li&gt;
&lt;/ul&gt;
&lt;h2&gt;★Lock锁&lt;/h2&gt;
&lt;p&gt;虽然我们可以理解同步代码块和同步方法的锁对象，但是我们并没有直接看到在哪里加上了锁，在哪里释放了锁，为了更加清晰的表达如何加锁和释放锁，JDK5以后提供了一个新的锁对象Lock&lt;/p&gt;
&lt;p&gt;Lock实现提供比使用synchronized方法和语句可以获得更广泛的锁定操作&lt;/p&gt;
&lt;p&gt;Lock中提供了获得锁和释放锁的方法&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;void lock()             获得锁&lt;/li&gt;
&lt;li&gt;void unlock()        释放锁&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;Lock是接口不能直接实例化，可以采用它的实现类&lt;code&gt;ReentrantLock&lt;/code&gt;来实例化&lt;/p&gt;
&lt;p&gt;ReentrantLock的构造方法&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;ReentrantLock()  创建一个ReentrantLock的实例&lt;/li&gt;
&lt;/ul&gt;
&lt;h4&gt;&lt;strong&gt;注意&lt;/strong&gt;：一般释放锁unlock要放入&lt;strong&gt;finally&lt;/strong&gt;中。&lt;/h4&gt;
&lt;p&gt;下面我们使用Lock来更新一下Ticket类&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;&lt;span class="kd"&gt;public&lt;/span&gt; &lt;span class="kd"&gt;class&lt;/span&gt; &lt;span class="nc"&gt;Ticket&lt;/span&gt; &lt;span class="kd"&gt;implements&lt;/span&gt; &lt;span class="n"&gt;Runnable&lt;/span&gt; &lt;span class="p"&gt;{&lt;/span&gt;

    &lt;span class="kd"&gt;private&lt;/span&gt; &lt;span class="kt"&gt;int&lt;/span&gt; &lt;span class="n"&gt;ticketCount&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="mi"&gt;100&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;

    &lt;span class="c1"&gt;//锁对象Lock&lt;/span&gt;
    &lt;span class="kd"&gt;private&lt;/span&gt; &lt;span class="n"&gt;Lock&lt;/span&gt; &lt;span class="n"&gt;lock&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="k"&gt;new&lt;/span&gt; &lt;span class="n"&gt;ReentrantLock&lt;/span&gt;&lt;span class="p"&gt;();&lt;/span&gt;

    &lt;span class="nd"&gt;@Override&lt;/span&gt;
    &lt;span class="kd"&gt;public&lt;/span&gt; &lt;span class="kt"&gt;void&lt;/span&gt; &lt;span class="nf"&gt;run&lt;/span&gt;&lt;span class="p"&gt;()&lt;/span&gt; &lt;span class="p"&gt;{&lt;/span&gt;
        &lt;span class="k"&gt;while&lt;/span&gt; &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="kc"&gt;true&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt; &lt;span class="p"&gt;{&lt;/span&gt;
            &lt;span class="c1"&gt;//开启Lock锁&lt;/span&gt;
            &lt;span class="n"&gt;lock&lt;/span&gt;&lt;span class="p"&gt;.&lt;/span&gt;&lt;span class="na"&gt;lock&lt;/span&gt;&lt;span class="p"&gt;();&lt;/span&gt;
            &lt;span class="k"&gt;try&lt;/span&gt; &lt;span class="p"&gt;{&lt;/span&gt;
                &lt;span class="k"&gt;if&lt;/span&gt; &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;ticketCount&lt;/span&gt; &lt;span class="o"&gt;==&lt;/span&gt; &lt;span class="mi"&gt;0&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt; &lt;span class="p"&gt;{&lt;/span&gt;
                    &lt;span class="k"&gt;break&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;
                &lt;span class="p"&gt;}&lt;/span&gt; &lt;span class="k"&gt;else&lt;/span&gt; &lt;span class="p"&gt;{&lt;/span&gt;
                    &lt;span class="n"&gt;Thread&lt;/span&gt;&lt;span class="p"&gt;.&lt;/span&gt;&lt;span class="na"&gt;sleep&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="mi"&gt;100&lt;/span&gt;&lt;span class="p"&gt;);&lt;/span&gt;
                    &lt;span class="k"&gt;this&lt;/span&gt;&lt;span class="p"&gt;.&lt;/span&gt;&lt;span class="na"&gt;ticketCount&lt;/span&gt; &lt;span class="o"&gt;-=&lt;/span&gt; &lt;span class="mi"&gt;1&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;
                    &lt;span class="n"&gt;System&lt;/span&gt;&lt;span class="p"&gt;.&lt;/span&gt;&lt;span class="na"&gt;out&lt;/span&gt;&lt;span class="p"&gt;.&lt;/span&gt;&lt;span class="na"&gt;println&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;Thread&lt;/span&gt;&lt;span class="p"&gt;.&lt;/span&gt;&lt;span class="na"&gt;currentThread&lt;/span&gt;&lt;span class="p"&gt;().&lt;/span&gt;&lt;span class="na"&gt;getName&lt;/span&gt;&lt;span class="p"&gt;()&lt;/span&gt; &lt;span class="o"&gt;+&lt;/span&gt; &lt;span class="s"&gt;&amp;quot;正在卖票,还剩有&amp;quot;&lt;/span&gt; &lt;span class="o"&gt;+&lt;/span&gt; &lt;span class="k"&gt;this&lt;/span&gt;&lt;span class="p"&gt;.&lt;/span&gt;&lt;span class="na"&gt;ticketCount&lt;/span&gt; &lt;span class="o"&gt;+&lt;/span&gt; &lt;span class="s"&gt;&amp;quot;张&amp;quot;&lt;/span&gt;&lt;span class="p"&gt;);&lt;/span&gt;
                &lt;span class="p"&gt;}&lt;/span&gt;
            &lt;span class="p"&gt;}&lt;/span&gt; &lt;span class="k"&gt;catch&lt;/span&gt; &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;Exception&lt;/span&gt; &lt;span class="n"&gt;e&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt; &lt;span class="p"&gt;{&lt;/span&gt;
                &lt;span class="n"&gt;e&lt;/span&gt;&lt;span class="p"&gt;.&lt;/span&gt;&lt;span class="na"&gt;printStackTrace&lt;/span&gt;&lt;span class="p"&gt;();&lt;/span&gt;
            &lt;span class="p"&gt;}&lt;/span&gt; &lt;span class="k"&gt;finally&lt;/span&gt; &lt;span class="p"&gt;{&lt;/span&gt;
                &lt;span class="c1"&gt;//释放Lock锁&lt;/span&gt;
                &lt;span class="n"&gt;lock&lt;/span&gt;&lt;span class="p"&gt;.&lt;/span&gt;&lt;span class="na"&gt;unlock&lt;/span&gt;&lt;span class="p"&gt;();&lt;/span&gt;
            &lt;span class="p"&gt;}&lt;/span&gt;
        &lt;span class="p"&gt;}&lt;/span&gt;
    &lt;span class="p"&gt;}&lt;/span&gt;
&lt;span class="p"&gt;}&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;h1&gt;死锁&lt;/h1&gt;
&lt;p&gt;线程死锁是指由于两个或者多个线程互相持有对方所需要的资源，导致这些线程处于等待状态，无法前往执行。&lt;/p&gt;
&lt;p&gt;建议：不要写锁的嵌套。&lt;/p&gt;
</description><author>jialna@qq.com (乐心湖)</author><guid isPermaLink="true">/archives/thread-safe-java/</guid><pubDate>Mon, 09 Mar 2020 15:10:00 +0806</pubDate></item><item><title>线性代数粗暴解题</title><link>/archives/math-1/</link><description>&lt;h2&gt;线性代数粗暴解题&lt;/h2&gt;
&lt;h3&gt;二阶行列式&lt;/h3&gt;
&lt;p&gt;&lt;figure&gt;&lt;img data-width="1301" data-height="654" src="https://cdn.xn2001.com/2020/03/11/20200311214150.png" alt="" /&gt;&lt;/figure&gt;&lt;/p&gt;
&lt;h3&gt;三阶行列式及多阶&lt;/h3&gt;
&lt;p&gt;计算：将对角线的一边的数全部变为0，对角线各个相乘。&lt;/p&gt;
&lt;p&gt;第一行的作用是使从第二行开始每一行的第一位数变成0，以此类推。&lt;/p&gt;
&lt;p&gt;&lt;figure&gt;&lt;img data-width="1216" data-height="722" src="https://cdn.xn2001.com/2020/03/11/20200311223839.png" alt="" /&gt;&lt;/figure&gt;&lt;/p&gt;
&lt;p&gt;&lt;figure&gt;&lt;img data-width="1619" data-height="970" src="https://cdn.xn2001.com/2020/03/11/20200311221232.png" alt="" /&gt;&lt;/figure&gt;&lt;/p&gt;
&lt;h3&gt;计算技巧&lt;/h3&gt;
&lt;h4&gt;某行（列）乘以K，等于K乘此行列式&lt;/h4&gt;
&lt;p&gt;&lt;figure&gt;&lt;img data-width="857" data-height="506" src="https://cdn.xn2001.com/2020/03/12/20200312005609.png" alt="" /&gt;&lt;/figure&gt;&lt;/p&gt;
&lt;p&gt;&lt;figure&gt;&lt;img data-width="889" data-height="432" src="https://cdn.xn2001.com/2020/03/12/20200312010357.png" alt="" /&gt;&lt;/figure&gt;&lt;/p&gt;
&lt;h4&gt;互换两行（列），行列式变号&lt;/h4&gt;
&lt;p&gt;&lt;figure&gt;&lt;img data-width="843" data-height="425" src="https://cdn.xn2001.com/2020/03/12/20200312010913.png" alt="" /&gt;&lt;/figure&gt;&lt;/p&gt;
&lt;p&gt;鄙人自拍丑照一张。换行记得取反。&lt;/p&gt;
&lt;p&gt;&lt;figure&gt;&lt;img data-width="1878" data-height="1080" src="https://cdn.xn2001.com/2020/03/12/20200312012314.jpg" alt="" /&gt;&lt;/figure&gt;&lt;/p&gt;
&lt;h3&gt;计算取巧&lt;/h3&gt;
&lt;h4&gt;1. 对角线x一样,其他数字a一样 且n行n列&lt;/h4&gt;
&lt;p&gt;公式：&lt;figure&gt;&lt;img data-width="393" data-height="78" src="https://cdn.xn2001.com/2020/03/12/20200312114702.png" alt="" /&gt;&lt;/figure&gt;&lt;/p&gt;
&lt;p&gt;&lt;figure&gt;&lt;img data-width="1054" data-height="712" src="https://cdn.xn2001.com/2020/03/12/20200312114350.png" alt="" /&gt;&lt;/figure&gt;&lt;/p&gt;
&lt;h4&gt;2. n次方&lt;/h4&gt;
&lt;p&gt;大的数减掉每一个小的，减到不能减了，相乘。&lt;/p&gt;
&lt;p&gt;&lt;figure&gt;&lt;img data-width="1325" data-height="740" src="https://cdn.xn2001.com/2020/03/12/20200312125000.png" alt="" /&gt;&lt;/figure&gt;&lt;/p&gt;
&lt;h4&gt;3. 两个特性&lt;/h4&gt;
&lt;ol&gt;
&lt;li&gt;两行（列）相同或成比例时，行列式为&lt;strong&gt;0&lt;/strong&gt;&lt;/li&gt;
&lt;li&gt;某行（列）为两项相加减时，行列式可拆成两个行列式相加减&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;&lt;figure&gt;&lt;img data-width="1281" data-height="776" src="https://cdn.xn2001.com/2020/03/12/20200312125644.png" alt="" /&gt;&lt;/figure&gt;&lt;/p&gt;
&lt;h4&gt;4. 余子数，代数余子数&lt;/h4&gt;
&lt;p&gt;rc，r代表行，c代表列&lt;/p&gt;
&lt;p&gt;23指的是第二行第三列的数&lt;/p&gt;
&lt;p&gt;12值的是第一行第二列的数&lt;/p&gt;
&lt;p&gt;求余子数 M ：除了那一行那一列，将其余的数拿出来计算值。&lt;/p&gt;
&lt;p&gt;求代数余子数 A ：&lt;img src="https://cdn.xn2001.com/2020/03/12/20200312181021.jpg" style="zoom: 15%;" /&gt;&lt;/p&gt;
&lt;p&gt;&lt;figure&gt;&lt;img data-width="951" data-height="568" src="https://cdn.xn2001.com/2020/03/12/20200312175349.png" alt="" /&gt;&lt;/figure&gt;&lt;/p&gt;
&lt;p&gt;&lt;figure&gt;&lt;img data-width="1050" data-height="728" src="https://cdn.xn2001.com/2020/03/12/20200312175306.png" alt="" /&gt;&lt;/figure&gt;&lt;/p&gt;
&lt;h4&gt;5. 当行或列0较多时&lt;/h4&gt;
&lt;p&gt;可以采用下面两公式，即每个数分别乘上它的代数余子式，最后求和&lt;/p&gt;
&lt;p&gt;&lt;figure&gt;&lt;img data-width="1281" data-height="605" src="https://cdn.xn2001.com/2020/03/12/20200312233222.png" alt="" /&gt;&lt;/figure&gt;&lt;/p&gt;
&lt;h4&gt;6. 多个A或M相加减&lt;/h4&gt;
&lt;p&gt;&lt;figure&gt;&lt;img data-width="1164" data-height="732" src="https://cdn.xn2001.com/2020/03/13/20200313100801.png" alt="" /&gt;&lt;/figure&gt;&lt;/p&gt;
&lt;h4&gt;7. 给一方程组，判断其解的情况&lt;/h4&gt;
&lt;p&gt;&lt;figure&gt;&lt;img data-width="1347" data-height="691" src="https://cdn.xn2001.com/2020/03/13/20200313101156.png" alt="" /&gt;&lt;/figure&gt;&lt;/p&gt;
</description><author>jialna@qq.com (乐心湖)</author><guid isPermaLink="true">/archives/math-1/</guid><pubDate>Fri, 13 Mar 2020 12:10:00 +0806</pubDate></item><item><title>SpringBoot动态Banner</title><link>/archives/banner-springboot/</link><description>&lt;h2&gt;SpringBoot动态Banner&lt;/h2&gt;
&lt;h3&gt;1. 新建banner.txt文件&lt;/h3&gt;
&lt;p&gt;在src/main/resources路径下新建banner.txt文件&lt;/p&gt;
&lt;p&gt;&lt;figure&gt;&lt;img data-width="440" data-height="129" src="https://cdn.xn2001.com/2020/03/14/20200314001310.png" alt="" /&gt;&lt;/figure&gt;&lt;/p&gt;
&lt;h3&gt;2. 借助第三方工具转化内容&lt;/h3&gt;
&lt;p&gt;可以使用 &lt;a href="http://www.network-science.de/ascii/"&gt;http://www.network-science.de/ascii/&lt;/a&gt; 输入文本. 将结果复制出来&lt;/p&gt;
&lt;p&gt;&lt;figure&gt;&lt;img data-width="1383" data-height="781" src="https://cdn.xn2001.com/2020/03/14/20200314001143.png" alt="" /&gt;&lt;/figure&gt;&lt;/p&gt;
&lt;h3&gt;3. 填入banner.txt&lt;/h3&gt;
&lt;p&gt;banner.txt文件中填写好需要打印的字符串内容&lt;/p&gt;
&lt;p&gt;&lt;figure&gt;&lt;img data-width="1500" data-height="761" src="https://cdn.xn2001.com/2020/03/14/20200314002053.png" alt="" /&gt;&lt;/figure&gt;&lt;/p&gt;
</description><author>jialna@qq.com (乐心湖)</author><guid isPermaLink="true">/archives/banner-springboot/</guid><pubDate>Sat, 14 Mar 2020 01:30:00 +0806</pubDate></item><item><title>SpringBoot日志功能</title><link>/archives/log-springboot/</link><description>&lt;h2&gt;SpringBoot日志功能&lt;/h2&gt;
&lt;h3&gt;日志常见的需求&lt;/h3&gt;
&lt;p&gt;• 将关键数据打印在控制台&lt;/p&gt;
&lt;p&gt;• 将关键数据打印在文件中&lt;/p&gt;
&lt;p&gt;• 日志分类，根据日志不同类型打印到不同文件&lt;/p&gt;
&lt;p&gt;• 不同的运行环境，打印不同的日志内容&lt;/p&gt;
&lt;p&gt;• 日志自动清理&lt;/p&gt;
&lt;h3&gt;SpringBoot默认使用&lt;/h3&gt;
&lt;p&gt;日志抽象层：SLF4J&lt;/p&gt;
&lt;p&gt;日志实现：LogBack&lt;/p&gt;
&lt;p&gt;官方帮助文档 &lt;a href="http://www.slf4j.org/manual.html"&gt;http://www.slf4j.org/manual.html&lt;/a&gt;&lt;/p&gt;
&lt;h3&gt;测试使用&lt;/h3&gt;
&lt;p&gt;根据官方文档,我们测试一下.这里要注意的是import的是slf4j&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;&lt;span class="kn"&gt;import&lt;/span&gt; &lt;span class="nn"&gt;org.slf4j.Logger&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;&lt;span class="nd"&gt;@RestController&lt;/span&gt;
&lt;span class="kd"&gt;public&lt;/span&gt; &lt;span class="kd"&gt;class&lt;/span&gt; &lt;span class="nc"&gt;HelloController&lt;/span&gt; &lt;span class="p"&gt;{&lt;/span&gt;

    &lt;span class="nd"&gt;@RequestMapping&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="s"&gt;&amp;quot;/hello&amp;quot;&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;
    &lt;span class="kd"&gt;public&lt;/span&gt; &lt;span class="kt"&gt;void&lt;/span&gt; &lt;span class="nf"&gt;Hello&lt;/span&gt;&lt;span class="p"&gt;()&lt;/span&gt; &lt;span class="p"&gt;{&lt;/span&gt;
        &lt;span class="n"&gt;Logger&lt;/span&gt; &lt;span class="n"&gt;logger&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="n"&gt;LoggerFactory&lt;/span&gt;&lt;span class="p"&gt;.&lt;/span&gt;&lt;span class="na"&gt;getLogger&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;HelloController&lt;/span&gt;&lt;span class="p"&gt;.&lt;/span&gt;&lt;span class="na"&gt;class&lt;/span&gt;&lt;span class="p"&gt;);&lt;/span&gt;
        &lt;span class="n"&gt;logger&lt;/span&gt;&lt;span class="p"&gt;.&lt;/span&gt;&lt;span class="na"&gt;info&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="s"&gt;&amp;quot;Hello World&amp;quot;&lt;/span&gt;&lt;span class="p"&gt;);&lt;/span&gt;
    &lt;span class="p"&gt;}&lt;/span&gt;
&lt;span class="p"&gt;}&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;&lt;figure&gt;&lt;img data-width="955" data-height="403" src="https://cdn.xn2001.com/2020/03/14/20200314003939.png" alt="" /&gt;&lt;/figure&gt;&lt;/p&gt;
&lt;p&gt;&lt;figure&gt;&lt;img data-width="1341" data-height="368" src="https://cdn.xn2001.com/2020/03/14/20200314004152.png" alt="" /&gt;&lt;/figure&gt;&lt;/p&gt;
&lt;h3&gt;简化开发&lt;/h3&gt;
&lt;p&gt;在pom.xml中添加Lombok依赖。&lt;/p&gt;
&lt;p&gt;（ 这里idea一定要安装有Lombok插件，具体也可以看我另一篇简短的记录&lt;a href="https://www.xn2001.com/archives/360.html"&gt;idea简化插件&lt;/a&gt; ）&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;&lt;span class="nt"&gt;&amp;lt;dependency&amp;gt;&lt;/span&gt;
            &lt;span class="nt"&gt;&amp;lt;groupId&amp;gt;&lt;/span&gt;org.projectlombok&lt;span class="nt"&gt;&amp;lt;/groupId&amp;gt;&lt;/span&gt;
            &lt;span class="nt"&gt;&amp;lt;artifactId&amp;gt;&lt;/span&gt;lombok&lt;span class="nt"&gt;&amp;lt;/artifactId&amp;gt;&lt;/span&gt;
            &lt;span class="nt"&gt;&amp;lt;version&amp;gt;&lt;/span&gt;1.18.12&lt;span class="nt"&gt;&amp;lt;/version&amp;gt;&lt;/span&gt;
            &lt;span class="nt"&gt;&amp;lt;scope&amp;gt;&lt;/span&gt;provided&lt;span class="nt"&gt;&amp;lt;/scope&amp;gt;&lt;/span&gt;
        &lt;span class="nt"&gt;&amp;lt;/dependency&amp;gt;&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;使用&lt;code&gt;log.info&lt;/code&gt;就可以直接取代之前的代码。是不是很方便。（实际开发里Lombok使用效率是非常非常高的）&lt;/p&gt;
&lt;p&gt;&lt;figure&gt;&lt;img data-width="641" data-height="343" src="https://cdn.xn2001.com/2020/03/14/20200314013615.png" alt="" /&gt;&lt;/figure&gt;&lt;/p&gt;
&lt;h3&gt;Logback特点&lt;/h3&gt;
&lt;p&gt;• 更快的实现&lt;/p&gt;
&lt;p&gt;• 非常充分测试&lt;/p&gt;
&lt;p&gt;• 非常充分的文档&lt;/p&gt;
&lt;p&gt;• 自动重新加载配置文件&lt;/p&gt;
&lt;p&gt;• 自动压缩&lt;/p&gt;
&lt;p&gt;• 自动去除旧的日志文件&lt;/p&gt;
&lt;p&gt;• 牛逼就对了&lt;/p&gt;
&lt;h3&gt;Logback开发&lt;/h3&gt;
&lt;ul&gt;
&lt;li&gt;在/resources目录下下新建logback-spring.xml  (名字必须是这个，这样SpringBoot才可以自动完成配置，约定大于配置)&lt;/li&gt;
&lt;li&gt;格局规则配置logback-spring.xml&lt;/li&gt;
&lt;li&gt;在/resources目录下新建application.yml（这一步不是必须的，你可以在项目创建时自带的application.properties中来完成同样的操作）&lt;/li&gt;
&lt;li&gt;配置项目环境和日志目录&lt;/li&gt;
&lt;/ul&gt;
&lt;h3&gt;Logback日志配置&lt;/h3&gt;
&lt;p&gt;级别：TRACE &amp;lt; DEBUG &amp;lt; INFO &amp;lt; WARN &amp;lt; ERROR &amp;lt; FATAL&lt;/p&gt;
&lt;p&gt;下面是一套带详细注解的配置，写在logback-spring.xml，只要会用即可。&lt;/p&gt;
&lt;p&gt;在application.yml中使用 &lt;code&gt;logging.file.path= 文件名&lt;/code&gt;  //直接在跟目录下创建该文件且自动 帮你创建好文件&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;logging:
  file:
    path: boot.log&lt;/code&gt;&lt;/pre&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;&lt;span class="cp"&gt;&amp;lt;?xml version=&amp;quot;1.0&amp;quot; encoding=&amp;quot;UTF-8&amp;quot;?&amp;gt;&lt;/span&gt;
&lt;span class="c"&gt;&amp;lt;!-- 日志级别从低到高分为TRACE &amp;lt; DEBUG &amp;lt; INFO &amp;lt; WARN &amp;lt; ERROR &amp;lt; FATAL，如果设置为WARN，则低于WARN的信息都不会输出 --&amp;gt;&lt;/span&gt;
&lt;span class="c"&gt;&amp;lt;!-- scan:当此属性设置为true时，配置文件如果发生改变，将会被重新加载，默认值为true --&amp;gt;&lt;/span&gt;
&lt;span class="c"&gt;&amp;lt;!-- scanPeriod:设置监测配置文件是否有修改的时间间隔，如果没有给出时间单位，默认单位是毫秒。当scan为true时，此属性生效。默认的时间间隔为1分钟。 --&amp;gt;&lt;/span&gt;
&lt;span class="c"&gt;&amp;lt;!-- debug:当此属性设置为true时，将打印出logback内部日志信息，实时查看logback运行状态。默认值为false。 --&amp;gt;&lt;/span&gt;
&lt;span class="nt"&gt;&amp;lt;configuration&lt;/span&gt;  &lt;span class="na"&gt;scan=&lt;/span&gt;&lt;span class="s"&gt;&amp;quot;true&amp;quot;&lt;/span&gt; &lt;span class="na"&gt;scanPeriod=&lt;/span&gt;&lt;span class="s"&gt;&amp;quot;10 seconds&amp;quot;&lt;/span&gt;&lt;span class="nt"&gt;&amp;gt;&lt;/span&gt;

    &lt;span class="c"&gt;&amp;lt;!--&amp;lt;property name=&amp;quot;log.path&amp;quot; value=&amp;quot;D:/bmslog&amp;quot; /&amp;gt;--&amp;gt;&lt;/span&gt;
    &lt;span class="nt"&gt;&amp;lt;springProperty&lt;/span&gt; &lt;span class="na"&gt;scope=&lt;/span&gt;&lt;span class="s"&gt;&amp;quot;context&amp;quot;&lt;/span&gt; &lt;span class="na"&gt;name=&lt;/span&gt;&lt;span class="s"&gt;&amp;quot;log.path&amp;quot;&lt;/span&gt; &lt;span class="na"&gt;source=&lt;/span&gt;&lt;span class="s"&gt;&amp;quot;logging.file.path&amp;quot;&lt;/span&gt; &lt;span class="na"&gt;defaultValue=&lt;/span&gt;&lt;span class="s"&gt;&amp;quot;/home/logs/bms&amp;quot;&lt;/span&gt;&lt;span class="nt"&gt;/&amp;gt;&lt;/span&gt;
    &lt;span class="nt"&gt;&amp;lt;contextName&amp;gt;&lt;/span&gt;logback&lt;span class="nt"&gt;&amp;lt;/contextName&amp;gt;&lt;/span&gt;

    &lt;span class="c"&gt;&amp;lt;!-- 彩色日志 --&amp;gt;&lt;/span&gt;
    &lt;span class="c"&gt;&amp;lt;!-- 彩色日志依赖的渲染类 --&amp;gt;&lt;/span&gt;
    &lt;span class="nt"&gt;&amp;lt;conversionRule&lt;/span&gt; &lt;span class="na"&gt;conversionWord=&lt;/span&gt;&lt;span class="s"&gt;&amp;quot;clr&amp;quot;&lt;/span&gt; &lt;span class="na"&gt;converterClass=&lt;/span&gt;&lt;span class="s"&gt;&amp;quot;org.springframework.boot.logging.logback.ColorConverter&amp;quot;&lt;/span&gt; &lt;span class="nt"&gt;/&amp;gt;&lt;/span&gt;
    &lt;span class="nt"&gt;&amp;lt;conversionRule&lt;/span&gt; &lt;span class="na"&gt;conversionWord=&lt;/span&gt;&lt;span class="s"&gt;&amp;quot;wex&amp;quot;&lt;/span&gt; &lt;span class="na"&gt;converterClass=&lt;/span&gt;&lt;span class="s"&gt;&amp;quot;org.springframework.boot.logging.logback.WhitespaceThrowableProxyConverter&amp;quot;&lt;/span&gt; &lt;span class="nt"&gt;/&amp;gt;&lt;/span&gt;
    &lt;span class="nt"&gt;&amp;lt;conversionRule&lt;/span&gt; &lt;span class="na"&gt;conversionWord=&lt;/span&gt;&lt;span class="s"&gt;&amp;quot;wEx&amp;quot;&lt;/span&gt; &lt;span class="na"&gt;converterClass=&lt;/span&gt;&lt;span class="s"&gt;&amp;quot;org.springframework.boot.logging.logback.ExtendedWhitespaceThrowableProxyConverter&amp;quot;&lt;/span&gt; &lt;span class="nt"&gt;/&amp;gt;&lt;/span&gt;

    &lt;span class="c"&gt;&amp;lt;!-- 彩色日志格式 --&amp;gt;&lt;/span&gt;
    &lt;span class="nt"&gt;&amp;lt;property&lt;/span&gt; &lt;span class="na"&gt;name=&lt;/span&gt;&lt;span class="s"&gt;&amp;quot;CONSOLE_LOG_PATTERN&amp;quot;&lt;/span&gt; &lt;span class="na"&gt;value=&lt;/span&gt;&lt;span class="s"&gt;&amp;quot;${CONSOLE_LOG_PATTERN:-%clr(%d{yyyy-MM-dd HH:mm:ss.SSS}){faint} %clr(${LOG_LEVEL_PATTERN:-%5p}) %clr(${PID:- }){magenta} %clr(---){faint} %clr([%15.15t]){faint} %clr(%-40.40logger{39}){cyan} %clr(:){faint} %m%n${LOG_EXCEPTION_CONVERSION_WORD:-%wEx}}&amp;quot;&lt;/span&gt;&lt;span class="nt"&gt;/&amp;gt;&lt;/span&gt;

    &lt;span class="c"&gt;&amp;lt;!--输出到控制台--&amp;gt;&lt;/span&gt;
    &lt;span class="nt"&gt;&amp;lt;appender&lt;/span&gt; &lt;span class="na"&gt;name=&lt;/span&gt;&lt;span class="s"&gt;&amp;quot;CONSOLE&amp;quot;&lt;/span&gt; &lt;span class="na"&gt;class=&lt;/span&gt;&lt;span class="s"&gt;&amp;quot;ch.qos.logback.core.ConsoleAppender&amp;quot;&lt;/span&gt;&lt;span class="nt"&gt;&amp;gt;&lt;/span&gt;
        &lt;span class="c"&gt;&amp;lt;!--此日志appender是为开发使用，只配置最底级别，控制台输出的日志级别是大于或等于此级别的日志信息--&amp;gt;&lt;/span&gt;
        &lt;span class="nt"&gt;&amp;lt;filter&lt;/span&gt; &lt;span class="na"&gt;class=&lt;/span&gt;&lt;span class="s"&gt;&amp;quot;ch.qos.logback.classic.filter.ThresholdFilter&amp;quot;&lt;/span&gt;&lt;span class="nt"&gt;&amp;gt;&lt;/span&gt;
            &lt;span class="nt"&gt;&amp;lt;level&amp;gt;&lt;/span&gt;debug&lt;span class="nt"&gt;&amp;lt;/level&amp;gt;&lt;/span&gt;
        &lt;span class="nt"&gt;&amp;lt;/filter&amp;gt;&lt;/span&gt;
        &lt;span class="nt"&gt;&amp;lt;encoder&amp;gt;&lt;/span&gt;
            &lt;span class="nt"&gt;&amp;lt;Pattern&amp;gt;&lt;/span&gt;${CONSOLE_LOG_PATTERN}&lt;span class="nt"&gt;&amp;lt;/Pattern&amp;gt;&lt;/span&gt;
            &lt;span class="c"&gt;&amp;lt;!-- 设置字符集 --&amp;gt;&lt;/span&gt;
            &lt;span class="nt"&gt;&amp;lt;charset&amp;gt;&lt;/span&gt;UTF-8&lt;span class="nt"&gt;&amp;lt;/charset&amp;gt;&lt;/span&gt;
        &lt;span class="nt"&gt;&amp;lt;/encoder&amp;gt;&lt;/span&gt;
    &lt;span class="nt"&gt;&amp;lt;/appender&amp;gt;&lt;/span&gt;

    &lt;span class="c"&gt;&amp;lt;!--输出到文件--&amp;gt;&lt;/span&gt;
    &lt;span class="c"&gt;&amp;lt;!-- 时间滚动输出 level为 DEBUG 日志 --&amp;gt;&lt;/span&gt;
    &lt;span class="c"&gt;&amp;lt;!--RollingFileAppender的作用是滚动记录文件，先将日志记录到指定文件，当符合某个条件时再将日志记录到其他文件--&amp;gt;&lt;/span&gt;
    &lt;span class="nt"&gt;&amp;lt;appender&lt;/span&gt; &lt;span class="na"&gt;name=&lt;/span&gt;&lt;span class="s"&gt;&amp;quot;DEBUG_FILE&amp;quot;&lt;/span&gt; &lt;span class="na"&gt;class=&lt;/span&gt;&lt;span class="s"&gt;&amp;quot;ch.qos.logback.core.rolling.RollingFileAppender&amp;quot;&lt;/span&gt;&lt;span class="nt"&gt;&amp;gt;&lt;/span&gt;
        &lt;span class="c"&gt;&amp;lt;!-- 正在记录的日志文件的路径及文件名 --&amp;gt;&lt;/span&gt;
        &lt;span class="nt"&gt;&amp;lt;file&amp;gt;&lt;/span&gt;${log.path}/log_debug.log&lt;span class="nt"&gt;&amp;lt;/file&amp;gt;&lt;/span&gt;
        &lt;span class="c"&gt;&amp;lt;!--日志文件输出格式--&amp;gt;&lt;/span&gt;
        &lt;span class="nt"&gt;&amp;lt;encoder&amp;gt;&lt;/span&gt;
            &lt;span class="c"&gt;&amp;lt;!--&lt;/span&gt;
&lt;span class="c"&gt;                   日志输出格式：&lt;/span&gt;
&lt;span class="c"&gt;                   %d表示日期时间，%thread表示线程名，%-5level：级别从左显示5个字符宽度&lt;/span&gt;
&lt;span class="c"&gt;                   %logger{50} 表示logger名字最长50个字符，否则按照句点分割。&lt;/span&gt;
&lt;span class="c"&gt;                   %msg：日志消息，%n是换行符&lt;/span&gt;
&lt;span class="c"&gt;            --&amp;gt;&lt;/span&gt;
            &lt;span class="nt"&gt;&amp;lt;pattern&amp;gt;&lt;/span&gt;%d{yyyy-MM-dd HH:mm:ss.SSS} [%thread] %-5level %logger{50} - %msg%n&lt;span class="nt"&gt;&amp;lt;/pattern&amp;gt;&lt;/span&gt;
            &lt;span class="nt"&gt;&amp;lt;charset&amp;gt;&lt;/span&gt;UTF-8&lt;span class="nt"&gt;&amp;lt;/charset&amp;gt;&lt;/span&gt; &lt;span class="c"&gt;&amp;lt;!-- 设置字符集 --&amp;gt;&lt;/span&gt;
        &lt;span class="nt"&gt;&amp;lt;/encoder&amp;gt;&lt;/span&gt;
        &lt;span class="c"&gt;&amp;lt;!-- 日志记录器的滚动策略，按日期，按大小记录 --&amp;gt;&lt;/span&gt;
        &lt;span class="c"&gt;&amp;lt;!-- &amp;lt;rollingPolicy&amp;gt;的作用是当发生滚动时，定义RollingFileAppender的行为，其中TimeBasedRollingPolicy是最常用的滚动策略，它根据时间指定滚动策略，既负责滚动也负责触发滚动--&amp;gt;&lt;/span&gt;
        &lt;span class="nt"&gt;&amp;lt;rollingPolicy&lt;/span&gt; &lt;span class="na"&gt;class=&lt;/span&gt;&lt;span class="s"&gt;&amp;quot;ch.qos.logback.core.rolling.TimeBasedRollingPolicy&amp;quot;&lt;/span&gt;&lt;span class="nt"&gt;&amp;gt;&lt;/span&gt;
            &lt;span class="c"&gt;&amp;lt;!-- 日志归档 --&amp;gt;&lt;/span&gt;
            &lt;span class="nt"&gt;&amp;lt;fileNamePattern&amp;gt;&lt;/span&gt;${log.path}/debug/log-debug-%d{yyyy-MM-dd}.%i.log&lt;span class="nt"&gt;&amp;lt;/fileNamePattern&amp;gt;&lt;/span&gt;
            &lt;span class="nt"&gt;&amp;lt;timeBasedFileNamingAndTriggeringPolicy&lt;/span&gt; &lt;span class="na"&gt;class=&lt;/span&gt;&lt;span class="s"&gt;&amp;quot;ch.qos.logback.core.rolling.SizeAndTimeBasedFNATP&amp;quot;&lt;/span&gt;&lt;span class="nt"&gt;&amp;gt;&lt;/span&gt;
                &lt;span class="nt"&gt;&amp;lt;maxFileSize&amp;gt;&lt;/span&gt;100MB&lt;span class="nt"&gt;&amp;lt;/maxFileSize&amp;gt;&lt;/span&gt;
            &lt;span class="nt"&gt;&amp;lt;/timeBasedFileNamingAndTriggeringPolicy&amp;gt;&lt;/span&gt;
            &lt;span class="c"&gt;&amp;lt;!--日志文件保留天数--&amp;gt;&lt;/span&gt;
            &lt;span class="nt"&gt;&amp;lt;maxHistory&amp;gt;&lt;/span&gt;15&lt;span class="nt"&gt;&amp;lt;/maxHistory&amp;gt;&lt;/span&gt;
        &lt;span class="nt"&gt;&amp;lt;/rollingPolicy&amp;gt;&lt;/span&gt;
        &lt;span class="c"&gt;&amp;lt;!-- 此日志文件只记录debug级别的 --&amp;gt;&lt;/span&gt;
        &lt;span class="nt"&gt;&amp;lt;filter&lt;/span&gt; &lt;span class="na"&gt;class=&lt;/span&gt;&lt;span class="s"&gt;&amp;quot;ch.qos.logback.classic.filter.LevelFilter&amp;quot;&lt;/span&gt;&lt;span class="nt"&gt;&amp;gt;&lt;/span&gt;
            &lt;span class="nt"&gt;&amp;lt;level&amp;gt;&lt;/span&gt;debug&lt;span class="nt"&gt;&amp;lt;/level&amp;gt;&lt;/span&gt;
            &lt;span class="c"&gt;&amp;lt;!-- &amp;lt;onMatch&amp;gt;:用于配置符合过滤条件的操作 --&amp;gt;&lt;/span&gt;
            &lt;span class="nt"&gt;&amp;lt;onMatch&amp;gt;&lt;/span&gt;ACCEPT&lt;span class="nt"&gt;&amp;lt;/onMatch&amp;gt;&lt;/span&gt;
            &lt;span class="nt"&gt;&amp;lt;onMismatch&amp;gt;&lt;/span&gt;DENY&lt;span class="nt"&gt;&amp;lt;/onMismatch&amp;gt;&lt;/span&gt;
        &lt;span class="nt"&gt;&amp;lt;/filter&amp;gt;&lt;/span&gt;
    &lt;span class="nt"&gt;&amp;lt;/appender&amp;gt;&lt;/span&gt;

    &lt;span class="c"&gt;&amp;lt;!-- 时间滚动输出 level为 INFO 日志 --&amp;gt;&lt;/span&gt;
    &lt;span class="nt"&gt;&amp;lt;appender&lt;/span&gt; &lt;span class="na"&gt;name=&lt;/span&gt;&lt;span class="s"&gt;&amp;quot;INFO_FILE&amp;quot;&lt;/span&gt; &lt;span class="na"&gt;class=&lt;/span&gt;&lt;span class="s"&gt;&amp;quot;ch.qos.logback.core.rolling.RollingFileAppender&amp;quot;&lt;/span&gt;&lt;span class="nt"&gt;&amp;gt;&lt;/span&gt;
        &lt;span class="c"&gt;&amp;lt;!-- 正在记录的日志文件的路径及文件名 --&amp;gt;&lt;/span&gt;
        &lt;span class="nt"&gt;&amp;lt;file&amp;gt;&lt;/span&gt;${log.path}/log_info.log&lt;span class="nt"&gt;&amp;lt;/file&amp;gt;&lt;/span&gt;
        &lt;span class="c"&gt;&amp;lt;!--日志文件输出格式--&amp;gt;&lt;/span&gt;
        &lt;span class="nt"&gt;&amp;lt;encoder&amp;gt;&lt;/span&gt;
            &lt;span class="nt"&gt;&amp;lt;pattern&amp;gt;&lt;/span&gt;%d{yyyy-MM-dd HH:mm:ss.SSS} [%thread] %-5level %logger{50} - %msg%n&lt;span class="nt"&gt;&amp;lt;/pattern&amp;gt;&lt;/span&gt;
            &lt;span class="nt"&gt;&amp;lt;charset&amp;gt;&lt;/span&gt;UTF-8&lt;span class="nt"&gt;&amp;lt;/charset&amp;gt;&lt;/span&gt;
        &lt;span class="nt"&gt;&amp;lt;/encoder&amp;gt;&lt;/span&gt;
        &lt;span class="c"&gt;&amp;lt;!-- 日志记录器的滚动策略，按日期，按大小记录 --&amp;gt;&lt;/span&gt;
        &lt;span class="nt"&gt;&amp;lt;rollingPolicy&lt;/span&gt; &lt;span class="na"&gt;class=&lt;/span&gt;&lt;span class="s"&gt;&amp;quot;ch.qos.logback.core.rolling.TimeBasedRollingPolicy&amp;quot;&lt;/span&gt;&lt;span class="nt"&gt;&amp;gt;&lt;/span&gt;
            &lt;span class="c"&gt;&amp;lt;!-- 每天日志归档路径以及格式 --&amp;gt;&lt;/span&gt;
            &lt;span class="nt"&gt;&amp;lt;fileNamePattern&amp;gt;&lt;/span&gt;${log.path}/info/log-info-%d{yyyy-MM-dd}.%i.log&lt;span class="nt"&gt;&amp;lt;/fileNamePattern&amp;gt;&lt;/span&gt;
            &lt;span class="nt"&gt;&amp;lt;timeBasedFileNamingAndTriggeringPolicy&lt;/span&gt; &lt;span class="na"&gt;class=&lt;/span&gt;&lt;span class="s"&gt;&amp;quot;ch.qos.logback.core.rolling.SizeAndTimeBasedFNATP&amp;quot;&lt;/span&gt;&lt;span class="nt"&gt;&amp;gt;&lt;/span&gt;
                &lt;span class="nt"&gt;&amp;lt;maxFileSize&amp;gt;&lt;/span&gt;100MB&lt;span class="nt"&gt;&amp;lt;/maxFileSize&amp;gt;&lt;/span&gt;
            &lt;span class="nt"&gt;&amp;lt;/timeBasedFileNamingAndTriggeringPolicy&amp;gt;&lt;/span&gt;
            &lt;span class="c"&gt;&amp;lt;!--日志文件保留天数--&amp;gt;&lt;/span&gt;
            &lt;span class="nt"&gt;&amp;lt;maxHistory&amp;gt;&lt;/span&gt;15&lt;span class="nt"&gt;&amp;lt;/maxHistory&amp;gt;&lt;/span&gt;
        &lt;span class="nt"&gt;&amp;lt;/rollingPolicy&amp;gt;&lt;/span&gt;
        &lt;span class="c"&gt;&amp;lt;!-- 此日志文件只记录info级别的 --&amp;gt;&lt;/span&gt;
        &lt;span class="nt"&gt;&amp;lt;filter&lt;/span&gt; &lt;span class="na"&gt;class=&lt;/span&gt;&lt;span class="s"&gt;&amp;quot;ch.qos.logback.classic.filter.LevelFilter&amp;quot;&lt;/span&gt;&lt;span class="nt"&gt;&amp;gt;&lt;/span&gt;
            &lt;span class="nt"&gt;&amp;lt;level&amp;gt;&lt;/span&gt;info&lt;span class="nt"&gt;&amp;lt;/level&amp;gt;&lt;/span&gt;
            &lt;span class="nt"&gt;&amp;lt;onMatch&amp;gt;&lt;/span&gt;ACCEPT&lt;span class="nt"&gt;&amp;lt;/onMatch&amp;gt;&lt;/span&gt;
            &lt;span class="nt"&gt;&amp;lt;onMismatch&amp;gt;&lt;/span&gt;DENY&lt;span class="nt"&gt;&amp;lt;/onMismatch&amp;gt;&lt;/span&gt;
        &lt;span class="nt"&gt;&amp;lt;/filter&amp;gt;&lt;/span&gt;
    &lt;span class="nt"&gt;&amp;lt;/appender&amp;gt;&lt;/span&gt;

    &lt;span class="c"&gt;&amp;lt;!-- 时间滚动输出 level为 WARN 日志 --&amp;gt;&lt;/span&gt;
    &lt;span class="nt"&gt;&amp;lt;appender&lt;/span&gt; &lt;span class="na"&gt;name=&lt;/span&gt;&lt;span class="s"&gt;&amp;quot;WARN_FILE&amp;quot;&lt;/span&gt; &lt;span class="na"&gt;class=&lt;/span&gt;&lt;span class="s"&gt;&amp;quot;ch.qos.logback.core.rolling.RollingFileAppender&amp;quot;&lt;/span&gt;&lt;span class="nt"&gt;&amp;gt;&lt;/span&gt;
        &lt;span class="c"&gt;&amp;lt;!-- 正在记录的日志文件的路径及文件名 --&amp;gt;&lt;/span&gt;
        &lt;span class="nt"&gt;&amp;lt;file&amp;gt;&lt;/span&gt;${log.path}/log_warn.log&lt;span class="nt"&gt;&amp;lt;/file&amp;gt;&lt;/span&gt;
        &lt;span class="c"&gt;&amp;lt;!--日志文件输出格式--&amp;gt;&lt;/span&gt;
        &lt;span class="nt"&gt;&amp;lt;encoder&amp;gt;&lt;/span&gt;
            &lt;span class="nt"&gt;&amp;lt;pattern&amp;gt;&lt;/span&gt;%d{yyyy-MM-dd HH:mm:ss.SSS} [%thread] %-5level %logger{50} - %msg%n&lt;span class="nt"&gt;&amp;lt;/pattern&amp;gt;&lt;/span&gt;
            &lt;span class="nt"&gt;&amp;lt;charset&amp;gt;&lt;/span&gt;UTF-8&lt;span class="nt"&gt;&amp;lt;/charset&amp;gt;&lt;/span&gt; &lt;span class="c"&gt;&amp;lt;!-- 此处设置字符集 --&amp;gt;&lt;/span&gt;
        &lt;span class="nt"&gt;&amp;lt;/encoder&amp;gt;&lt;/span&gt;
        &lt;span class="c"&gt;&amp;lt;!-- 日志记录器的滚动策略，按日期，按大小记录 --&amp;gt;&lt;/span&gt;
        &lt;span class="nt"&gt;&amp;lt;rollingPolicy&lt;/span&gt; &lt;span class="na"&gt;class=&lt;/span&gt;&lt;span class="s"&gt;&amp;quot;ch.qos.logback.core.rolling.TimeBasedRollingPolicy&amp;quot;&lt;/span&gt;&lt;span class="nt"&gt;&amp;gt;&lt;/span&gt;
            &lt;span class="nt"&gt;&amp;lt;fileNamePattern&amp;gt;&lt;/span&gt;${log.path}/warn/log-warn-%d{yyyy-MM-dd}.%i.log&lt;span class="nt"&gt;&amp;lt;/fileNamePattern&amp;gt;&lt;/span&gt;
            &lt;span class="nt"&gt;&amp;lt;timeBasedFileNamingAndTriggeringPolicy&lt;/span&gt; &lt;span class="na"&gt;class=&lt;/span&gt;&lt;span class="s"&gt;&amp;quot;ch.qos.logback.core.rolling.SizeAndTimeBasedFNATP&amp;quot;&lt;/span&gt;&lt;span class="nt"&gt;&amp;gt;&lt;/span&gt;
                &lt;span class="nt"&gt;&amp;lt;maxFileSize&amp;gt;&lt;/span&gt;100MB&lt;span class="nt"&gt;&amp;lt;/maxFileSize&amp;gt;&lt;/span&gt;
            &lt;span class="nt"&gt;&amp;lt;/timeBasedFileNamingAndTriggeringPolicy&amp;gt;&lt;/span&gt;
            &lt;span class="c"&gt;&amp;lt;!--日志文件保留天数--&amp;gt;&lt;/span&gt;
            &lt;span class="nt"&gt;&amp;lt;maxHistory&amp;gt;&lt;/span&gt;15&lt;span class="nt"&gt;&amp;lt;/maxHistory&amp;gt;&lt;/span&gt;
        &lt;span class="nt"&gt;&amp;lt;/rollingPolicy&amp;gt;&lt;/span&gt;
        &lt;span class="c"&gt;&amp;lt;!-- 此日志文件只记录warn级别的 --&amp;gt;&lt;/span&gt;
        &lt;span class="nt"&gt;&amp;lt;filter&lt;/span&gt; &lt;span class="na"&gt;class=&lt;/span&gt;&lt;span class="s"&gt;&amp;quot;ch.qos.logback.classic.filter.LevelFilter&amp;quot;&lt;/span&gt;&lt;span class="nt"&gt;&amp;gt;&lt;/span&gt;
            &lt;span class="nt"&gt;&amp;lt;level&amp;gt;&lt;/span&gt;warn&lt;span class="nt"&gt;&amp;lt;/level&amp;gt;&lt;/span&gt;
            &lt;span class="nt"&gt;&amp;lt;onMatch&amp;gt;&lt;/span&gt;ACCEPT&lt;span class="nt"&gt;&amp;lt;/onMatch&amp;gt;&lt;/span&gt;
            &lt;span class="nt"&gt;&amp;lt;onMismatch&amp;gt;&lt;/span&gt;DENY&lt;span class="nt"&gt;&amp;lt;/onMismatch&amp;gt;&lt;/span&gt;
        &lt;span class="nt"&gt;&amp;lt;/filter&amp;gt;&lt;/span&gt;
    &lt;span class="nt"&gt;&amp;lt;/appender&amp;gt;&lt;/span&gt;


    &lt;span class="c"&gt;&amp;lt;!-- 时间滚动输出 level为 ERROR 日志 --&amp;gt;&lt;/span&gt;
    &lt;span class="nt"&gt;&amp;lt;appender&lt;/span&gt; &lt;span class="na"&gt;name=&lt;/span&gt;&lt;span class="s"&gt;&amp;quot;ERROR_FILE&amp;quot;&lt;/span&gt; &lt;span class="na"&gt;class=&lt;/span&gt;&lt;span class="s"&gt;&amp;quot;ch.qos.logback.core.rolling.RollingFileAppender&amp;quot;&lt;/span&gt;&lt;span class="nt"&gt;&amp;gt;&lt;/span&gt;
        &lt;span class="c"&gt;&amp;lt;!-- 正在记录的日志文件的路径及文件名 --&amp;gt;&lt;/span&gt;
        &lt;span class="nt"&gt;&amp;lt;file&amp;gt;&lt;/span&gt;${log.path}/log_error.log&lt;span class="nt"&gt;&amp;lt;/file&amp;gt;&lt;/span&gt;
        &lt;span class="c"&gt;&amp;lt;!--日志文件输出格式--&amp;gt;&lt;/span&gt;
        &lt;span class="nt"&gt;&amp;lt;encoder&amp;gt;&lt;/span&gt;
            &lt;span class="nt"&gt;&amp;lt;pattern&amp;gt;&lt;/span&gt;%d{yyyy-MM-dd HH:mm:ss.SSS} [%thread] %-5level %logger{50} - %msg%n&lt;span class="nt"&gt;&amp;lt;/pattern&amp;gt;&lt;/span&gt;
            &lt;span class="nt"&gt;&amp;lt;charset&amp;gt;&lt;/span&gt;UTF-8&lt;span class="nt"&gt;&amp;lt;/charset&amp;gt;&lt;/span&gt; &lt;span class="c"&gt;&amp;lt;!-- 此处设置字符集 --&amp;gt;&lt;/span&gt;
        &lt;span class="nt"&gt;&amp;lt;/encoder&amp;gt;&lt;/span&gt;
        &lt;span class="c"&gt;&amp;lt;!-- 日志记录器的滚动策略，按日期，按大小记录 --&amp;gt;&lt;/span&gt;
        &lt;span class="nt"&gt;&amp;lt;rollingPolicy&lt;/span&gt; &lt;span class="na"&gt;class=&lt;/span&gt;&lt;span class="s"&gt;&amp;quot;ch.qos.logback.core.rolling.TimeBasedRollingPolicy&amp;quot;&lt;/span&gt;&lt;span class="nt"&gt;&amp;gt;&lt;/span&gt;
            &lt;span class="nt"&gt;&amp;lt;fileNamePattern&amp;gt;&lt;/span&gt;${log.path}/error/log-error-%d{yyyy-MM-dd}.%i.log&lt;span class="nt"&gt;&amp;lt;/fileNamePattern&amp;gt;&lt;/span&gt;
            &lt;span class="nt"&gt;&amp;lt;timeBasedFileNamingAndTriggeringPolicy&lt;/span&gt; &lt;span class="na"&gt;class=&lt;/span&gt;&lt;span class="s"&gt;&amp;quot;ch.qos.logback.core.rolling.SizeAndTimeBasedFNATP&amp;quot;&lt;/span&gt;&lt;span class="nt"&gt;&amp;gt;&lt;/span&gt;
                &lt;span class="nt"&gt;&amp;lt;maxFileSize&amp;gt;&lt;/span&gt;100MB&lt;span class="nt"&gt;&amp;lt;/maxFileSize&amp;gt;&lt;/span&gt;
            &lt;span class="nt"&gt;&amp;lt;/timeBasedFileNamingAndTriggeringPolicy&amp;gt;&lt;/span&gt;
            &lt;span class="c"&gt;&amp;lt;!--日志文件保留天数--&amp;gt;&lt;/span&gt;
            &lt;span class="nt"&gt;&amp;lt;maxHistory&amp;gt;&lt;/span&gt;15&lt;span class="nt"&gt;&amp;lt;/maxHistory&amp;gt;&lt;/span&gt;
        &lt;span class="nt"&gt;&amp;lt;/rollingPolicy&amp;gt;&lt;/span&gt;
        &lt;span class="c"&gt;&amp;lt;!-- 此日志文件只记录ERROR级别的 --&amp;gt;&lt;/span&gt;
        &lt;span class="nt"&gt;&amp;lt;filter&lt;/span&gt; &lt;span class="na"&gt;class=&lt;/span&gt;&lt;span class="s"&gt;&amp;quot;ch.qos.logback.classic.filter.LevelFilter&amp;quot;&lt;/span&gt;&lt;span class="nt"&gt;&amp;gt;&lt;/span&gt;
            &lt;span class="nt"&gt;&amp;lt;level&amp;gt;&lt;/span&gt;ERROR&lt;span class="nt"&gt;&amp;lt;/level&amp;gt;&lt;/span&gt;
            &lt;span class="nt"&gt;&amp;lt;onMatch&amp;gt;&lt;/span&gt;ACCEPT&lt;span class="nt"&gt;&amp;lt;/onMatch&amp;gt;&lt;/span&gt;
            &lt;span class="nt"&gt;&amp;lt;onMismatch&amp;gt;&lt;/span&gt;DENY&lt;span class="nt"&gt;&amp;lt;/onMismatch&amp;gt;&lt;/span&gt;
        &lt;span class="nt"&gt;&amp;lt;/filter&amp;gt;&lt;/span&gt;
    &lt;span class="nt"&gt;&amp;lt;/appender&amp;gt;&lt;/span&gt;

    &lt;span class="c"&gt;&amp;lt;!--&lt;/span&gt;
&lt;span class="c"&gt;        &amp;lt;logger&amp;gt;用来设置某一个包或者具体的某一个类的日志打印级别、以及指定&amp;lt;appender&amp;gt;。&amp;lt;logger&amp;gt;仅有一个name属性，&lt;/span&gt;
&lt;span class="c"&gt;        一个可选的level和一个可选的addtivity属性。&lt;/span&gt;
&lt;span class="c"&gt;        name:用来指定受此logger约束的某一个包或者具体的某一个类。&lt;/span&gt;
&lt;span class="c"&gt;        level:用来设置打印级别，大小写无关：TRACE, DEBUG, INFO, WARN, ERROR, ALL 和 OFF，&lt;/span&gt;
&lt;span class="c"&gt;              还有一个特俗值INHERITED或者同义词NULL，代表强制执行上级的级别。&lt;/span&gt;
&lt;span class="c"&gt;              如果未设置此属性，那么当前logger将会继承上级的级别。&lt;/span&gt;
&lt;span class="c"&gt;        addtivity:是否向上级logger传递打印信息。默认是true。&lt;/span&gt;
&lt;span class="c"&gt;    --&amp;gt;&lt;/span&gt;
    &lt;span class="c"&gt;&amp;lt;!--&amp;lt;logger name=&amp;quot;org.springframework.web&amp;quot; level=&amp;quot;info&amp;quot;/&amp;gt;--&amp;gt;&lt;/span&gt;
    &lt;span class="c"&gt;&amp;lt;!--&amp;lt;logger name=&amp;quot;org.springframework.scheduling.annotation.ScheduledAnnotationBeanPostProcessor&amp;quot; level=&amp;quot;INFO&amp;quot;/&amp;gt;--&amp;gt;&lt;/span&gt;
    &lt;span class="c"&gt;&amp;lt;!--&lt;/span&gt;
&lt;span class="c"&gt;        使用mybatis的时候，sql语句是debug下才会打印，而这里我们只配置了info，所以想要查看sql语句的话，有以下两种操作：&lt;/span&gt;
&lt;span class="c"&gt;        第一种把&amp;lt;root level=&amp;quot;info&amp;quot;&amp;gt;改成&amp;lt;root level=&amp;quot;DEBUG&amp;quot;&amp;gt;这样就会打印sql，不过这样日志那边会出现很多其他消息&lt;/span&gt;
&lt;span class="c"&gt;        第二种就是单独给dao下目录配置debug模式，代码如下，这样配置sql语句会打印，其他还是正常info级别：&lt;/span&gt;
&lt;span class="c"&gt;     --&amp;gt;&lt;/span&gt;


    &lt;span class="c"&gt;&amp;lt;!--&lt;/span&gt;
&lt;span class="c"&gt;        root节点是必选节点，用来指定最基础的日志输出级别，只有一个level属性&lt;/span&gt;
&lt;span class="c"&gt;        level:用来设置打印级别，大小写无关：TRACE, DEBUG, INFO, WARN, ERROR, ALL 和 OFF，&lt;/span&gt;
&lt;span class="c"&gt;        不能设置为INHERITED或者同义词NULL。默认是DEBUG&lt;/span&gt;
&lt;span class="c"&gt;        可以包含零个或多个元素，标识这个appender将会添加到这个logger。&lt;/span&gt;
&lt;span class="c"&gt;    --&amp;gt;&lt;/span&gt;

    &lt;span class="c"&gt;&amp;lt;!-- 多环境配置管理 --&amp;gt;&lt;/span&gt;
    &lt;span class="c"&gt;&amp;lt;!--开发环境:打印控制台--&amp;gt;&lt;/span&gt;
    &lt;span class="nt"&gt;&amp;lt;springProfile&lt;/span&gt; &lt;span class="na"&gt;name=&lt;/span&gt;&lt;span class="s"&gt;&amp;quot;dev&amp;quot;&lt;/span&gt;&lt;span class="nt"&gt;&amp;gt;&lt;/span&gt;
        &lt;span class="nt"&gt;&amp;lt;root&lt;/span&gt; &lt;span class="na"&gt;level=&lt;/span&gt;&lt;span class="s"&gt;&amp;quot;info&amp;quot;&lt;/span&gt;&lt;span class="nt"&gt;&amp;gt;&lt;/span&gt;
         &lt;span class="c"&gt;&amp;lt;!--&amp;lt;logger name=&amp;quot;com.nmys.view&amp;quot; level=&amp;quot;debug&amp;quot;/&amp;gt;--&amp;gt;&lt;/span&gt;
            &lt;span class="nt"&gt;&amp;lt;appender-ref&lt;/span&gt; &lt;span class="na"&gt;ref=&lt;/span&gt;&lt;span class="s"&gt;&amp;quot;CONSOLE&amp;quot;&lt;/span&gt;  &lt;span class="nt"&gt;/&amp;gt;&lt;/span&gt;
            &lt;span class="nt"&gt;&amp;lt;appender-ref&lt;/span&gt; &lt;span class="na"&gt;ref=&lt;/span&gt;&lt;span class="s"&gt;&amp;quot;DEBUG_FILE&amp;quot;&lt;/span&gt; &lt;span class="nt"&gt;/&amp;gt;&lt;/span&gt;
            &lt;span class="nt"&gt;&amp;lt;appender-ref&lt;/span&gt; &lt;span class="na"&gt;ref=&lt;/span&gt;&lt;span class="s"&gt;&amp;quot;INFO_FILE&amp;quot;&lt;/span&gt; &lt;span class="nt"&gt;/&amp;gt;&lt;/span&gt;
            &lt;span class="nt"&gt;&amp;lt;appender-ref&lt;/span&gt; &lt;span class="na"&gt;ref=&lt;/span&gt;&lt;span class="s"&gt;&amp;quot;WARN_FILE&amp;quot;&lt;/span&gt; &lt;span class="nt"&gt;/&amp;gt;&lt;/span&gt;
            &lt;span class="nt"&gt;&amp;lt;appender-ref&lt;/span&gt; &lt;span class="na"&gt;ref=&lt;/span&gt;&lt;span class="s"&gt;&amp;quot;ERROR_FILE&amp;quot;&lt;/span&gt; &lt;span class="nt"&gt;/&amp;gt;&lt;/span&gt;
        &lt;span class="nt"&gt;&amp;lt;/root&amp;gt;&lt;/span&gt;
    &lt;span class="nt"&gt;&amp;lt;/springProfile&amp;gt;&lt;/span&gt;
    &lt;span class="c"&gt;&amp;lt;!--线上环境:--&amp;gt;&lt;/span&gt;
    &lt;span class="nt"&gt;&amp;lt;springProfile&lt;/span&gt; &lt;span class="na"&gt;name=&lt;/span&gt;&lt;span class="s"&gt;&amp;quot;prod&amp;quot;&lt;/span&gt;&lt;span class="nt"&gt;&amp;gt;&lt;/span&gt;
        &lt;span class="nt"&gt;&amp;lt;root&lt;/span&gt; &lt;span class="na"&gt;level=&lt;/span&gt;&lt;span class="s"&gt;&amp;quot;info&amp;quot;&lt;/span&gt;&lt;span class="nt"&gt;&amp;gt;&lt;/span&gt;
            &lt;span class="nt"&gt;&amp;lt;appender-ref&lt;/span&gt; &lt;span class="na"&gt;ref=&lt;/span&gt;&lt;span class="s"&gt;&amp;quot;CONSOLE&amp;quot;&lt;/span&gt;  &lt;span class="nt"&gt;/&amp;gt;&lt;/span&gt;
            &lt;span class="nt"&gt;&amp;lt;appender-ref&lt;/span&gt; &lt;span class="na"&gt;ref=&lt;/span&gt;&lt;span class="s"&gt;&amp;quot;DEBUG_FILE&amp;quot;&lt;/span&gt; &lt;span class="nt"&gt;/&amp;gt;&lt;/span&gt;
            &lt;span class="nt"&gt;&amp;lt;appender-ref&lt;/span&gt; &lt;span class="na"&gt;ref=&lt;/span&gt;&lt;span class="s"&gt;&amp;quot;INFO_FILE&amp;quot;&lt;/span&gt; &lt;span class="nt"&gt;/&amp;gt;&lt;/span&gt;
            &lt;span class="nt"&gt;&amp;lt;appender-ref&lt;/span&gt; &lt;span class="na"&gt;ref=&lt;/span&gt;&lt;span class="s"&gt;&amp;quot;WARN_FILE&amp;quot;&lt;/span&gt; &lt;span class="nt"&gt;/&amp;gt;&lt;/span&gt;
            &lt;span class="nt"&gt;&amp;lt;appender-ref&lt;/span&gt; &lt;span class="na"&gt;ref=&lt;/span&gt;&lt;span class="s"&gt;&amp;quot;ERROR_FILE&amp;quot;&lt;/span&gt; &lt;span class="nt"&gt;/&amp;gt;&lt;/span&gt;
        &lt;span class="nt"&gt;&amp;lt;/root&amp;gt;&lt;/span&gt;
    &lt;span class="nt"&gt;&amp;lt;/springProfile&amp;gt;&lt;/span&gt;
    &lt;span class="c"&gt;&amp;lt;!--测试环境:--&amp;gt;&lt;/span&gt;
    &lt;span class="nt"&gt;&amp;lt;springProfile&lt;/span&gt; &lt;span class="na"&gt;name=&lt;/span&gt;&lt;span class="s"&gt;&amp;quot;test&amp;quot;&lt;/span&gt;&lt;span class="nt"&gt;&amp;gt;&lt;/span&gt;
        &lt;span class="nt"&gt;&amp;lt;root&lt;/span&gt; &lt;span class="na"&gt;level=&lt;/span&gt;&lt;span class="s"&gt;&amp;quot;info&amp;quot;&lt;/span&gt;&lt;span class="nt"&gt;&amp;gt;&lt;/span&gt;
            &lt;span class="nt"&gt;&amp;lt;appender-ref&lt;/span&gt; &lt;span class="na"&gt;ref=&lt;/span&gt;&lt;span class="s"&gt;&amp;quot;DEBUG_FILE&amp;quot;&lt;/span&gt; &lt;span class="nt"&gt;/&amp;gt;&lt;/span&gt;
            &lt;span class="nt"&gt;&amp;lt;appender-ref&lt;/span&gt; &lt;span class="na"&gt;ref=&lt;/span&gt;&lt;span class="s"&gt;&amp;quot;INFO_FILE&amp;quot;&lt;/span&gt; &lt;span class="nt"&gt;/&amp;gt;&lt;/span&gt;
            &lt;span class="nt"&gt;&amp;lt;appender-ref&lt;/span&gt; &lt;span class="na"&gt;ref=&lt;/span&gt;&lt;span class="s"&gt;&amp;quot;WARN_FILE&amp;quot;&lt;/span&gt; &lt;span class="nt"&gt;/&amp;gt;&lt;/span&gt;
            &lt;span class="nt"&gt;&amp;lt;appender-ref&lt;/span&gt; &lt;span class="na"&gt;ref=&lt;/span&gt;&lt;span class="s"&gt;&amp;quot;ERROR_FILE&amp;quot;&lt;/span&gt; &lt;span class="nt"&gt;/&amp;gt;&lt;/span&gt;
        &lt;span class="nt"&gt;&amp;lt;/root&amp;gt;&lt;/span&gt;
    &lt;span class="nt"&gt;&amp;lt;/springProfile&amp;gt;&lt;/span&gt;

&lt;span class="nt"&gt;&amp;lt;/configuration&amp;gt;&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;h3&gt;Logback的常规配置&lt;/h3&gt;
&lt;p&gt;configuration&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;p&gt;appender：写日志的组件&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;&lt;p&gt;logger：设置某一个类的日志打印级别&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;&lt;p&gt;root：根logger&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;
</description><author>jialna@qq.com (乐心湖)</author><guid isPermaLink="true">/archives/log-springboot/</guid><pubDate>Sat, 14 Mar 2020 03:34:00 +0806</pubDate></item><item><title>SpringBoot配置阿里Druid连接池</title><link>/archives/druid-connect-springboot/</link><description>&lt;p&gt;为什么使用阿里的Druid，主要的一点就是功能多，而且喜欢阿里！&lt;/p&gt;
&lt;p&gt;具体场景使用hikari还是druid根据需求，两个都应该有所了解。&lt;/p&gt;
&lt;h2&gt;如何在 SpringBoot 配置 druid 连接池&lt;/h2&gt;
&lt;h3&gt;一.  首先确保有相关依赖，检查pom.xml&lt;/h3&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;&lt;span class="nt"&gt;&amp;lt;dependency&amp;gt;&lt;/span&gt;
            &lt;span class="nt"&gt;&amp;lt;groupId&amp;gt;&lt;/span&gt;mysql&lt;span class="nt"&gt;&amp;lt;/groupId&amp;gt;&lt;/span&gt;
            &lt;span class="nt"&gt;&amp;lt;artifactId&amp;gt;&lt;/span&gt;mysql-connector-java&lt;span class="nt"&gt;&amp;lt;/artifactId&amp;gt;&lt;/span&gt;
        &lt;span class="nt"&gt;&amp;lt;/dependency&amp;gt;&lt;/span&gt;
        &lt;span class="nt"&gt;&amp;lt;dependency&amp;gt;&lt;/span&gt;
            &lt;span class="nt"&gt;&amp;lt;groupId&amp;gt;&lt;/span&gt;com.alibaba&lt;span class="nt"&gt;&amp;lt;/groupId&amp;gt;&lt;/span&gt;
            &lt;span class="nt"&gt;&amp;lt;artifactId&amp;gt;&lt;/span&gt;druid-spring-boot-starter&lt;span class="nt"&gt;&amp;lt;/artifactId&amp;gt;&lt;/span&gt;
            &lt;span class="nt"&gt;&amp;lt;version&amp;gt;&lt;/span&gt;1.1.21&lt;span class="nt"&gt;&amp;lt;/version&amp;gt;&lt;/span&gt;
        &lt;span class="nt"&gt;&amp;lt;/dependency&amp;gt;&lt;/span&gt;
        &lt;span class="nt"&gt;&amp;lt;dependency&amp;gt;&lt;/span&gt;
            &lt;span class="nt"&gt;&amp;lt;groupId&amp;gt;&lt;/span&gt;org.springframework.boot&lt;span class="nt"&gt;&amp;lt;/groupId&amp;gt;&lt;/span&gt;
            &lt;span class="nt"&gt;&amp;lt;artifactId&amp;gt;&lt;/span&gt;spring-boot-starter-jdbc&lt;span class="nt"&gt;&amp;lt;/artifactId&amp;gt;&lt;/span&gt;
        &lt;span class="nt"&gt;&amp;lt;/dependency&amp;gt;&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;h3&gt;二. 在application.yml中配置相关属性&lt;/h3&gt;
&lt;blockquote&gt;&lt;p&gt;这里需要提一下的是，当初我在学习这个的时候，教学说到druid需要注入bean再通过配置类来引入配置，但我自己测试中发现实际上无需这么麻烦。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;里面的配置可以自行就行增删改。&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;spring:
  datasource:
    driver-class-name: com.mysql.cj.jdbc.Driver
    url: jdbc:mysql://localhost:3306/mybatis?characterEncoding=UTF-8&amp;amp;useSSL=true&amp;amp;serverTimezone=UTC
    username: root
    password: 123456
    platform: mysql
    type: com.alibaba.druid.pool.DruidDataSource
    druid:
      # 初始化大小，最小，最大
      initialSize: 1
      minIdle: 3
      maxActive: 20
      # 配置获取连接等待超时的时间
      maxWait: 60000
      # 配置间隔多久才进行一次检测，检测需要关闭的空闲连接，单位是毫秒
      timeBetweenEvictionRunsMillis: 60000
      # 配置一个连接在池中最小生存的时间，单位是毫秒
      minEvictableIdleTimeMillis: 30000
      validationQuery: select 'x'
      testWhileIdle: true
      testOnBorrow: false
      testOnReturn: false
      # 是否缓存preparedStatement，打开PSCache，并且指定每个连接上PSCache的大小。官方建议MySQL下建议关闭，如果用SQL防火墙 建议打开
      poolPreparedStatements: true
      maxPoolPreparedStatementPerConnectionSize: 20
      # 配置监控统计拦截的filters，去掉后监控界面sql无法统计，'wall'用于防火墙
      filters: stat,wall,slf4j
      # 通过connectProperties属性来打开mergeSql功能；慢SQL记录
      connectionProperties: druid.stat.mergeSql=true;druid.stat.slowSqlMillis=5000&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;&lt;img src="https://cdn.xn2001.com/2020/03/16/20200316123113.png" style="zoom:90%;" /&gt;&lt;/p&gt;
&lt;h3&gt;三. 进行测试&lt;/h3&gt;
&lt;p&gt;我们在test中直接进行简单的debug即可。&lt;/p&gt;
&lt;p&gt;我们对打印这里进行断点，点击一下行数显示17的那个位置旁边即可。记得是右键使用debug而不是run。&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;&lt;span class="nd"&gt;@SpringBootTest&lt;/span&gt;
&lt;span class="kd"&gt;class&lt;/span&gt; &lt;span class="nc"&gt;DemoApplicationTests&lt;/span&gt; &lt;span class="p"&gt;{&lt;/span&gt;

    &lt;span class="nd"&gt;@Autowired&lt;/span&gt;
    &lt;span class="n"&gt;DataSource&lt;/span&gt; &lt;span class="n"&gt;dataSource&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;

    &lt;span class="nd"&gt;@Test&lt;/span&gt;
    &lt;span class="kt"&gt;void&lt;/span&gt; &lt;span class="nf"&gt;contextLoads&lt;/span&gt;&lt;span class="p"&gt;()&lt;/span&gt; &lt;span class="p"&gt;{&lt;/span&gt;
        &lt;span class="n"&gt;System&lt;/span&gt;&lt;span class="p"&gt;.&lt;/span&gt;&lt;span class="na"&gt;out&lt;/span&gt;&lt;span class="p"&gt;.&lt;/span&gt;&lt;span class="na"&gt;println&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;dataSource&lt;/span&gt;&lt;span class="p"&gt;.&lt;/span&gt;&lt;span class="na"&gt;getClass&lt;/span&gt;&lt;span class="p"&gt;());&lt;/span&gt;
    &lt;span class="p"&gt;}&lt;/span&gt;

&lt;span class="p"&gt;}&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;&lt;figure&gt;&lt;img data-width="1372" data-height="557" src="https://cdn.xn2001.com/2020/03/16/20200316124432.png" alt="" /&gt;&lt;/figure&gt;&lt;/p&gt;
&lt;p&gt;&lt;figure&gt;&lt;img data-width="1306" data-height="967" src="https://cdn.xn2001.com/2020/03/16/20200316124815.png" alt="" /&gt;&lt;/figure&gt;&lt;/p&gt;
&lt;p&gt;我们可以清晰的看到我们的配置成功引入，并且跟yml配置文件一模一样。&lt;/p&gt;
&lt;p&gt;这里我们的连接池就算配置完成了。&lt;/p&gt;
</description><author>jialna@qq.com (乐心湖)</author><guid isPermaLink="true">/archives/druid-connect-springboot/</guid><pubDate>Mon, 16 Mar 2020 15:34:00 +0806</pubDate></item></channel></rss>